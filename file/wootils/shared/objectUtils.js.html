<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">wootils/shared/objectUtils.js | wootils</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A set of Javascript utilities for building Node and browser apps."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="wootils"><meta property="twitter:description" content="A set of Javascript utilities for building Node and browser apps."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/wootils"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#browser">browser</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/browser/simpleStorage.js~SimpleStorage.html">SimpleStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageEntriesOptions">SimpleStorageEntriesOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageEntry">SimpleStorageEntry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageOptions">SimpleStorageOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorage">SimpleStorageStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorageAvailableMethod">SimpleStorageStorageAvailableMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorageDeleteMethod">SimpleStorageStorageDeleteMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorageGetMethod">SimpleStorageStorageGetMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorageLogger">SimpleStorageStorageLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorageOptions">SimpleStorageStorageOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SimpleStorageStorageSetMethod">SimpleStorageStorageSetMethod</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#node">node</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/node/appConfiguration.js~AppConfiguration.html">AppConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/node/environmentUtils.js~EnvironmentUtils.html">EnvironmentUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/node/errorHandler.js~ErrorHandler.html">ErrorHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/node/logger.js~Logger.html">Logger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/node/pathUtils.js~PathUtils.html">PathUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-appConfiguration">appConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-errorHandlerWithOptions">errorHandlerWithOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-appLoggerWithOptions">appLoggerWithOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loggerWithOptions">loggerWithOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-packageInfo">packageInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pathUtilsWithHome">pathUtilsWithHome</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-rootRequire">rootRequire</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-environmentUtils">environmentUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-errorHandler">errorHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-appLogger">appLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-logger">logger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-packageInfoProvider">packageInfoProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pathUtils">pathUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-rootRequireProvider">rootRequireProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-AppConfigurationOptions">AppConfigurationOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Provider">Provider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProviderRegisterMethod">ProviderRegisterMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://yarnpkg.com/en/package/jimple">Jimple</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#shared">shared</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/shared/apiClient.js~APIClient.html">APIClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/shared/eventsHub.js~EventsHub.html">EventsHub</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/wootils/shared/objectUtils.js~ObjectUtils.html">ObjectUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deferred">deferred</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extendPromise">extendPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-APIClientEndpoint">APIClientEndpoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-APIClientEndpoints">APIClientEndpoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FetchClient">FetchClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FetchOptions">FetchOptions</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">wootils/shared/objectUtils.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const extend = require(&apos;extend&apos;);
/**
 * A small collection of utility methods to work with objects.
 */
class ObjectUtils {
  /**
   * @throws {Error} is called. This class is meant to be have only static methods.
   * @ignore
   */
  constructor() {
    throw new Error(&apos;ObjectUtils is a static class&apos;);
  }
  /**
   * This method makes a deep merge of a list of objects into a new one. The method also supports
   * arrays.
   * @example
   * const objA = { a: &apos;first&apos; };
   * const objB = { b: &apos;second&apos; };
   * console.log(ObjectUtils.merge(objA, objB));
   * // Will output { a: &apos;first&apos;, b: &apos;second&apos; }
   * @example
   * const arrA = [{ a: &apos;first&apos; }];
   * const arrB = [{ b: &apos;second&apos; }];
   * console.log(ObjectUtils.merge(objA, objB));
   * // Will output [{ a: &apos;first&apos;, b: &apos;second&apos; }]
   * @param {...{Object}} targets The objects to merge.
   * @return {Object}
   */
  static merge(...targets) {
    const [firstTarget] = targets;
    const base = Array.isArray(firstTarget) ? [] : {};
    return extend(true, base, ...targets);
  }
  /**
   * Creates a deep copy of a given object.
   * @param {Object} target The object to copy.
   * @return {Object}
   */
  static copy(target) {
    return this.merge(target);
  }
  /**
   * Returns the value of an object property using a path.
   * @example
   * const obj = {
   *   propOne: {
   *     propOneSub: &apos;Charito!&apos;,
   *   },
   *   propTwo: &apos;!!!&apos;,
   * };
   * console.log(ObjectUtils.get(
   *   obj,
   *   &apos;propOne.propOneSub&apos;
   * ));
   * // Will output &apos;Charito!&apos;
   *
   * @param {Object}  target                The object from where the property will be read.
   * @param {string}  objPath               The path to the property.
   * @param {string}  [pathDelimiter=&apos;.&apos;]   The delimiter that will separate the path components.
   * @param {boolean} [failWithError=false] Whether or not to throw an error when the path is
   *                                        invalid. If this is `false`, the method will silently
   *                                        fail and return `undefined`.
   * @return {*}
   * @throws {Error} If the path is invalid and `failWithError` is set to `true`.
   */
  static get(target, objPath, pathDelimiter = &apos;.&apos;, failWithError = false) {
    const parts = objPath.split(pathDelimiter);
    const first = parts.shift();
    let currentElement = target[first];
    if (typeof currentElement === &apos;undefined&apos;) {
      if (failWithError) {
        throw new Error(`There&apos;s nothing on &apos;${objPath}&apos;`);
      }
    } else if (parts.length) {
      let currentPath = first;
      parts.some((currentPart) =&gt; {
        let breakLoop = false;
        currentPath += `${pathDelimiter}${currentPart}`;
        currentElement = currentElement[currentPart];
        if (typeof currentElement === &apos;undefined&apos;) {
          if (failWithError) {
            throw new Error(`There&apos;s nothing on &apos;${currentPath}&apos;`);
          } else {
            breakLoop = true;
          }
        }

        return breakLoop;
      });
    }

    return currentElement;
  }
  /**
   * Sets a property on an object using a path. If the path doesn&apos;t exist, it will be created.
   * @example
   * const target = {};
   * console.log(ObjectUtils.set(target, &apos;some.prop.path&apos;, &apos;some-value&apos;));
   * // Will output { some: { prop: { path: &apos;some-value&apos; } } }
   *
   * @param {Object}  target                The object where the property will be set.
   * @param {string}  objPath               The path for the property.
   * @param {*}       value                 The value to set on the property.
   * @param {string}  [pathDelimiter=&apos;.&apos;]   The delimiter that will separate the path components.
   * @param {boolean} [failWithError=false] Whether or not to throw an error when the path is
   *                                        invalid. If this is `false`, the method will silently
   *                                        fail and return `undefined`.
   * @return {Object} A copy of the original object with the added property/properties.
   * @throws {Error} If one of the path components is for a non-object property and
   *                 `failWithError` is set to `true`.
   */
  static set(
    target,
    objPath,
    value,
    pathDelimiter = &apos;.&apos;,
    failWithError = false
  ) {
    let result = this.copy(target);
    if (objPath.includes(pathDelimiter)) {
      const parts = objPath.split(pathDelimiter);
      const last = parts.pop();
      let currentElement = result;
      let currentPath = &apos;&apos;;
      parts.forEach((part) =&gt; {
        currentPath += `${pathDelimiter}${part}`;
        const element = currentElement[part];
        const elementType = typeof element;
        if (elementType === &apos;undefined&apos;) {
          currentElement[part] = {};
          currentElement = currentElement[part];
        } else if (elementType === &apos;object&apos;) {
          currentElement = currentElement[part];
        } else {
          const errorPath = currentPath.substr(pathDelimiter.length);
          if (failWithError) {
            throw new Error(
              `There&apos;s already an element of type &apos;${elementType}&apos; on &apos;${errorPath}&apos;`
            );
          } else {
            result = undefined;
          }
        }
      });

      if (result) {
        currentElement[last] = value;
      }
    } else {
      result[objPath] = value;
    }

    return result;
  }
  /**
   * Extracts a property or properties from an object in order to create a new one.
   * @example
   * const target = {
   *   name: {
   *     first: &apos;Rosario&apos;,
   *   },
   *   age: 3,
   *   address: {
   *     planet: &apos;earth&apos;,
   *     something: &apos;else&apos;,
   *   },
   * };
   * console.log(ObjectUtils.set(obj, [
   *   { &apos;name&apos;: &apos;name.first&apos;},
   *   &apos;age&apos;,
   *   &apos;address.planet&apos;
   * ]));
   * // Will output { name: &apos;Rosario&apos;, age: 3, address: { planet: &apos;earth&apos; } }
   * @param {Object}              target                The object from where the
   *                                                    property/properties will be extracted.
   * @param {Array|Object|string} objPaths              This can be a single path or a list of
   *                                                    them. And for this method, the paths are
   *                                                    not only strings but can also be an object
   *                                                    with a single key, the would be the path
   *                                                    to where to &quot;do the extraction&quot;, and the
   *                                                    value the path on the target object.
   * @param {string}              [pathDelimiter=&apos;.&apos;]   The delimiter that will separate the
   *                                                    path components.
   * @param {boolean}             [failWithError=false] Whether or not to throw an error when the
   *                                                    path is invalid. If this is `false`, the
   *                                                    method will silently fail an empty object.
   * @return {Object}
   */
  static extract(target, objPaths, pathDelimiter = &apos;.&apos;, failWithError = false) {
    const copied = this.copy(target);
    let result = {};
    (Array.isArray(objPaths) ? objPaths : [objPaths])
    .reduce((acc, objPath) =&gt; {
      let destPath;
      let originPath;
      if (typeof objPath === &apos;object&apos;) {
        [destPath] = Object.keys(objPath);
        originPath = objPath[destPath];
      } else {
        destPath = objPath;
        originPath = objPath;
      }

      return [...acc, {
        origin: originPath,
        customDest: destPath.includes(pathDelimiter),
        dest: destPath,
      }];
    }, [])
    .some((pathInfo) =&gt; {
      let breakLoop = false;
      const value = this.get(copied, pathInfo.origin, pathDelimiter, failWithError);
      if (typeof value !== &apos;undefined&apos;) {
        if (pathInfo.customDest) {
          result = this.set(result, pathInfo.dest, value, pathDelimiter, failWithError);
          if (typeof result === &apos;undefined&apos;) {
            breakLoop = true;
          }
        } else {
          result[pathInfo.dest] = value;
        }
      }

      return breakLoop;
    });

    return result;
  }
  /**
   * Deletes a property of an object using a path.
   * @example
   * const target = {
   *   propOne: {
   *     propOneSub: &apos;Charito!&apos;,
   *   },
   *   propTwo: &apos;!!!&apos;,
   * };
   * console.log(ObjectUtils.delete(
   *   target,
   *   &apos;propOne.propOneSub&apos;
   * ));
   * // Will output { propTwo: &apos;!!!&apos; }
   *
   * @param {Object}  target                      The object from where the property will be
   *                                              removed.
   * @param {string}  objPath                     The path to the property.
   * @param {String}  [pathDelimiter=&apos;.&apos;]         The delimiter that will separate the path
   *                                              components.
   * @param {Boolean} [cleanEmptyProperties=true] If this flag is `true` and after removing the
   *                                              property the parent object is empty, it will
   *                                              remove it recursively until a non empty parent
   *                                              object is found.
   * @param {boolean} [failWithError=false]       Whether or not to throw an error when the path
   *                                              is invalid. If this is `false`, the method will
   *                                              silently fail.
   * @return {Object} A copy of the original object with the removed property/properties.
   */
  static delete(
    target,
    objPath,
    pathDelimiter = &apos;.&apos;,
    cleanEmptyProperties = true,
    failWithError = false
  ) {
    const parts = objPath.split(pathDelimiter);
    const last = parts.pop();
    let result = this.copy(target);
    if (parts.length) {
      const parentPath = parts.join(pathDelimiter);
      const parentObj = this.get(
        result,
        parentPath,
        pathDelimiter,
        failWithError
      );
      delete parentObj[last];
      if (cleanEmptyProperties &amp;&amp; !Object.keys(parentObj).length) {
        result = this.delete(
          result,
          parentPath,
          pathDelimiter,
          cleanEmptyProperties,
          failWithError
        );
      }
    } else {
      delete result[last];
    }

    return result;
  }
  /**
   * Flatterns an object properties into a single level dictionary.
   * @example
   * const target = {
   *   propOne: {
   *     propOneSub: &apos;Charito!&apos;,
   *   },
   *   propTwo: &apos;!!!&apos;,
   * };
   * console.log(ObjectUtils.flat(target);
   * // Will output { &apos;propOne.propOneSub&apos;: &apos;Charito!&apos;, propTwo: &apos;!!!&apos; }
   *
   * @param {Object}                      target                The object to transform.
   * @param {String}                      [pathDelimiter=&apos;.&apos;]   The delimiter that will separate
   *                                                            the path components.
   * @param {String}                      [prefix=&apos;&apos;]           A custom prefix to be added before
   *                                                            the name of the properties. This
   *                                                            can be used on custom cases and
   *                                                            it&apos;s also used when the method
   *                                                            calls itself in order to flattern
   *                                                            a sub object.
   * @param {?Function(String,*):Boolean} [shouldFlattern=null] A custom function that can be used
   *                                                            in order to tell the method whether
   *                                                            an Object or an Array property
   *                                                            should be flattern or not. It will
   *                                                            receive the key for the property
   *                                                            and the Object/Array itself.
   * @return {Object}
   */
  static flat(target, pathDelimiter = &apos;.&apos;, prefix = &apos;&apos;, shouldFlattern = null) {
    let result = {};
    const namePrefix = prefix ? `${prefix}${pathDelimiter}` : &apos;&apos;;
    Object.keys(target).forEach((key) =&gt; {
      const name = `${namePrefix}${key}`;
      const value = target[key];
      const valueType = typeof value;
      if (valueType === &apos;object&apos; &amp;&amp; (!shouldFlattern || shouldFlattern(key, value))) {
        result = this.merge(result, this.flat(
          value,
          pathDelimiter,
          name,
          shouldFlattern
        ));
      } else {
        result[name] = valueType === &apos;object&apos; ? this.copy(value) : value;
      }
    });

    return result;
  }
  /**
   * This method does the exact opposite from `flat`: It takes an already flattern object and
   * restores it structure.
   * @example
   * const target = {
   *   &apos;propOne.propOneSub&apos;: &apos;Charito!
   *   propTwo: &apos;!!!&apos;,
   * };
   * console.log(ObjectUtils.unflat(target);
   * // Will output { propOne: { propOneSub: &apos;Charito!&apos; }, &apos;propTwo&apos;: &apos;!!!&apos; }
   *
   * @param {Object} target                The object to transform.
   * @param {String} [pathDelimiter=&apos;.&apos;]   The delimiter that will separate the path components.
   * @return {Object}
   */
  static unflat(target, pathDelimiter = &apos;.&apos;) {
    return Object.keys(target).reduce(
      (current, key) =&gt; this.set(current, key, target[key], pathDelimiter),
      {}
    );
  }
  /**
   * Formats all the keys on an object using a way similar to `.replace(regexp, ...)` but that
   * also works recursively and with _&quot;object paths&quot;_.
   * @example
   * const target = {
   *   prop_one: &apos;Charito!&apos;,
   * };
   * console.log(ObjectUtils.formatKeys(
   *   target,
   *   // Find all the keys with snake case.
   *   /([a-z])_([a-z])/g,
   *   // Using the same .replace style callback, replace it with lower camel case.
   *   (fullMatch, firstLetter, secondLetter) =&gt; {
   *     const newSecondLetter = secondLetter.toUpperCase();
   *     return `${firstLetter}${newSecondLetter}`;
   *   }
   * ));
   * // Will output { propOne: &apos;Charito!}.
   *
   * @param {Object}   target              The object for format.
   * @param {RegExp}   searchExpression    The regular expression the method will use &quot;match&quot; the
   *                                       keys.
   * @param {Function} replaceWith         The callback the method will call when formatting a
   *                                       replace. Think of `searchExpression` and `replaceWith`
   *                                       as the parameters of a `.replace` call, where the
   *                                       object is the key.
   * @param {Array}    [include=[]]        A list of keys or paths where the transformation will
   *                                       be made. If not specified, the method will use all the
   *                                       keys from the object.
   * @param {Array}    [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                       be made.
   * @param {string}   [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                       for both `include` and `exclude`.
   * @return {Object}
   */
  static formatKeys(
    target,
    searchExpression,
    replaceWith,
    include = [],
    exclude = [],
    pathDelimiter = &apos;.&apos;
  ) {
    // First of all, get all the keys from the target.
    const keys = Object.keys(target);
    /**
     * Then, check which keys are parent to other objects.
     * This is saved on a dictionary not only because it makes it easier to check if the method
     * should make a recursive call for a key, but also because when parsing the `exclude`
     * parameter, if one of items is a key (and not an specific path), the method won&apos;t make the
     * recursive call.
     */
    const hasChildrenByKey = {};
    keys.forEach((key) =&gt; {
      const value = target[key];
      hasChildrenByKey[key] = !!(
        value &amp;&amp;
        typeof value === &apos;object&apos; &amp;&amp;
        value !== null &amp;&amp;
        !Array.isArray(value) &amp;&amp;
        Object.keys(value)
      );
    });
    /**
     * Escape the path delimiter and create two regular expression: One that removes the path
     * delimiter from the start of a path and one that removes it from the end.
     * They are later used to normalize paths in order to avoid &quot;incomplete paths&quot; (paths that
     * end or start with the delimiter).
     */
    const escapedPathDelimiter = pathDelimiter.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &apos;\\$&amp;&apos;);
    const cleanPathStartExpression = new RegExp(`^${escapedPathDelimiter}`, &apos;i&apos;);
    const cleanPathEndExpression = new RegExp(`${escapedPathDelimiter}$`, &apos;i&apos;);
    /**
     * This dictionary will be used to save the `include` parameter that will be sent for specific
     * keys on recursive calls.
     * If `include` has a path like `myKey.mySubKey`, `myKey` is not transformed, but `mySubKey`
     * is saved on this dictionary (`{ myKey: [&apos;mySubKey&apos;]}`) and when the method applies the
     * formatting to the object, if `myKey` has an object, it will make a recursive all and
     * send `[&apos;mySubKey]` as its `include` parameter.
     */
    const subIncludeByKey = {};
    /**
     * This will be an array containing the final list of `keys` that should be tranformed.
     * To be clear, these keys will be from the top level, so, they won&apos;t be paths.
     * Thd following blocks will parse `include` and `exclude` in order to extract the real keys,
     * prepare the `include` and `exclude` for recursive calls, and save the actual keys
     * from the object &quot;at the current level of this call&quot; (no, it&apos;s not thinking about the
     * children :P).
     */
    let keysToFormat;
    // If the `include` parameter has paths/keys...
    if (include.length) {
      keysToFormat = include
      .map((includePath) =&gt; {
        // Normalize the path/key.
        const useIncludePath = includePath
        .replace(cleanPathStartExpression, &apos;&apos;)
        .replace(cleanPathEndExpression, &apos;&apos;);
        // Define the variable that will, eventually, have the real key.
        let key;
        // If the value is a path...
        if (useIncludePath.includes(pathDelimiter)) {
          // Split all its components.
          const pathParts = useIncludePath.split(pathDelimiter);
          // Get the first component, a.k.a. the real key.
          const pathKey = pathParts.shift();
          /**
           * This is very important: Since the path was specified with sub components (like
           * `myProp.mySubProp`), the method won&apos;t format the key, but the sub key(s)
           * (`mySubProp`).
           * The `key` is set to `false` so it will be later removed using `.filter`.
           */
          key = false;
          /**
           * If there&apos;s no array for the key on the &quot;`include` dictionary for recursive calls&quot;,
           * create an empty one.
           */
          if (!subIncludeByKey[pathKey]) {
            subIncludeByKey[pathKey] = [];
          }
          // Save the rest of the path to be sent on the recursive call as `include`.
          subIncludeByKey[pathKey].push(pathParts.join(pathDelimiter));
        } else {
          // If the value wasn&apos;t a path, assume it&apos;s a key, and set it to be returned.
          key = useIncludePath;
        }

        return key;
      })
      // Remove any `false` keys.
      .filter((key) =&gt; key);
    } else {
      // There&apos;s nothing on the `include` parameter, so use all the keys.
      keysToFormat = keys;
    }
    /**
     * Similar to `subIncludeByKey`, this dictionary will be used to save the `exclude` parameter
     * that will be sent for specific keys on recursive calls.
     * If `exclude` has a path like `myKey.mySubKey`, `myKey` will be transformed, but `mySubKey`
     * is saved on this dictionary (`{ myKey: [&apos;mySubKey&apos;]}`) and when the method applies the
     * formatting to the object, if `myKey` has an object, it will make a recursive all and
     * send `[&apos;mySubKey]` as its `exclude` parameter.
     */
    const subExcludeByKey = {};
    // If the `include` parameter has paths/keys...
    if (exclude.length) {
      /**
       * Create a dictionary of keys that should be removed from `keysToFormat`.
       * It&apos;s easier to have them on a list and use `.filter` than actually call `.splice` for
       * every key that should be removed.
       */
      const keysToRemove = [];
      exclude.forEach((excludePath) =&gt; {
        // Normalize the path/key.
        const useExcludePath = excludePath
        .replace(cleanPathStartExpression, &apos;&apos;)
        .replace(cleanPathEndExpression, &apos;&apos;);
        // If the value is a path...
        if (useExcludePath.includes(pathDelimiter)) {
          // Split all its components.
          const pathParts = useExcludePath.split(pathDelimiter);
          // Get the first component, a.k.a. the real key.
          const pathKey = pathParts.shift();
          /**
           * If there&apos;s no array for the key on the &quot;`exclude` dictionary for recursive calls&quot;,
           * create an empty one.
           */
          if (!subExcludeByKey[pathKey]) {
            subExcludeByKey[pathKey] = [];
          }
          // Save the rest of the path to be sent on the recursive call as `exclude`.
          subExcludeByKey[pathKey].push(pathParts.join(pathDelimiter));
        } else {
          /**
           * If the value wasn&apos;t a path, assume it&apos;s a key, turn the flag on the &quot;children
           * dictionary&quot; to `false`, to prevent recursive calls, and add the key to the list
           * of keys that will be removed from `keysToFormat`.
           * Basically: If it&apos;s a key, don&apos;t format it and don&apos;t make recursive calls for it.
           */
          hasChildrenByKey[useExcludePath] = false;
          keysToRemove.push(useExcludePath);
        }
      });
      // Remove keys that should be excluded.
      keysToFormat = keysToFormat.filter((key) =&gt; !keysToRemove.includes(key));
    }
    // &quot;Finally&quot;, reduce all the keys from the object and create the new one...
    return keys.reduce(
      (newObj, key) =&gt; {
        /**
         * Define the new key and value for the object property. Depending on the validations,
         * they may be replaced with formatted ones.
         */
        let newKey;
        let newValue;
        /**
         * Get the current value for the key, in case it&apos;s needed for a recursive call or just
         * to send it back because it didn&apos;t need any change.
         */
        const value = target[key];
        // If the key should be formatted, apply the formatting; otherwise, keep the original.
        if (keysToFormat.includes(key)) {
          newKey = key.replace(searchExpression, replaceWith);
        } else {
          newKey = key;
        }
        /**
         * If the paths/keys on `exclude` didn&apos;t modify the &quot;children dictionary&quot; for the key and
         * the value is another object, make a recursive call; otherwise, just use the original
         * value.
         */
        if (hasChildrenByKey[key]) {
          newValue = this.formatKeys(
            value,
            searchExpression,
            replaceWith,
            subIncludeByKey[key] || [],
            subExcludeByKey[key] || [],
            pathDelimiter
          );
        } else {
          newValue = value;
        }
        // &quot;Done&quot;, return the new object with the &quot;new key&quot; and the &quot;new value&quot;.
        return Object.assign({}, newObj, {
          [newKey]: newValue,
        });
      },
      {}
    );
  }
  /**
   * A shorthand method for {@link ObjectUtils.formatKeys} that transforms the keys from
   * `lowerCamelCase` to `snake_case`.
   * @param {Object} target              The object for format.
   * @param {Array}  [include=[]]        A list of keys or paths where the transformation will
   *                                     be made. If not specified, the method will use all the
   *                                     keys from the object.
   * @param {Array}  [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                     be made.
   * @param {string} [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                     for both `include` and `exclude`.
   * @return {Object}
   */
  static lowerCamelToSnakeKeys(target, include = [], exclude = [], pathDelimiter = &apos;.&apos;) {
    return this.formatKeys(
      target,
      /([a-z])([A-Z])/g,
      (fullMatch, firstLetter, secondLetter) =&gt; {
        const newSecondLetter = secondLetter.toLowerCase();
        return `${firstLetter}_${newSecondLetter}`;
      },
      include,
      exclude,
      pathDelimiter
    );
  }
  /**
   * A shorthand method for {@link ObjectUtils.formatKeys} that transforms the keys from
   * `lowerCamelCase` to `dash-case`.
   * @param {Object} target              The object for format.
   * @param {Array}  [include=[]]        A list of keys or paths where the transformation will
   *                                     be made. If not specified, the method will use all the
   *                                     keys from the object.
   * @param {Array}  [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                     be made.
   * @param {string} [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                     for both `include` and `exclude`.
   * @return {Object}
   */
  static lowerCamelToDashKeys(target, include = [], exclude = [], pathDelimiter = &apos;.&apos;) {
    return this.formatKeys(
      target,
      /([a-z])([A-Z])/g,
      (fullMatch, firstLetter, secondLetter) =&gt; {
        const newSecondLetter = secondLetter.toLowerCase();
        return `${firstLetter}-${newSecondLetter}`;
      },
      include,
      exclude,
      pathDelimiter
    );
  }
  /**
   * A shorthand method for {@link ObjectUtils.formatKeys} that transforms the keys from
   * `snake_case` to `lowerCamelCase`.
   * @param {Object} target              The object for format.
   * @param {Array}  [include=[]]        A list of keys or paths where the transformation will
   *                                     be made. If not specified, the method will use all the
   *                                     keys from the object.
   * @param {Array}  [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                     be made.
   * @param {string} [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                     for both `include` and `exclude`.
   * @return {Object}
   */
  static snakeToLowerCamelKeys(target, include = [], exclude = [], pathDelimiter = &apos;.&apos;) {
    return this.formatKeys(
      target,
      /([a-z])_([a-z])/g,
      (fullMatch, firstLetter, secondLetter) =&gt; {
        const newSecondLetter = secondLetter.toUpperCase();
        return `${firstLetter}${newSecondLetter}`;
      },
      include,
      exclude,
      pathDelimiter
    );
  }
  /**
   * A shorthand method for {@link ObjectUtils.formatKeys} that transforms the keys from
   * `snake_case` to `dash-case`.
   * @param {Object} target              The object for format.
   * @param {Array}  [include=[]]        A list of keys or paths where the transformation will
   *                                     be made. If not specified, the method will use all the
   *                                     keys from the object.
   * @param {Array}  [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                     be made.
   * @param {string} [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                     for both `include` and `exclude`.
   * @return {Object}
   */
  static snakeToDashKeys(target, include = [], exclude = [], pathDelimiter = &apos;.&apos;) {
    return this.formatKeys(
      target,
      /([a-z])_([a-z])/g,
      (fullMatch, firstLetter, secondLetter) =&gt; `${firstLetter}-${secondLetter}`,
      include,
      exclude,
      pathDelimiter
    );
  }
  /**
   * A shorthand method for {@link ObjectUtils.formatKeys} that transforms the keys from
   * `dash-case` to `lowerCamelCase`.
   * @param {Object} target              The object for format.
   * @param {Array}  [include=[]]        A list of keys or paths where the transformation will
   *                                     be made. If not specified, the method will use all the
   *                                     keys from the object.
   * @param {Array}  [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                     be made.
   * @param {string} [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                     for both `include` and `exclude`.
   * @return {Object}
   */
  static dashToLowerCamelKeys(target, include = [], exclude = [], pathDelimiter = &apos;.&apos;) {
    return this.formatKeys(
      target,
      /([a-z])-([a-z])/g,
      (fullMatch, firstLetter, secondLetter) =&gt; {
        const newSecondLetter = secondLetter.toUpperCase();
        return `${firstLetter}${newSecondLetter}`;
      },
      include,
      exclude,
      pathDelimiter
    );
  }
  /**
   * A shorthand method for {@link ObjectUtils.formatKeys} that transforms the keys from
   * `dash-case` to `snake_case`.
   * @param {Object} target              The object for format.
   * @param {Array}  [include=[]]        A list of keys or paths where the transformation will
   *                                     be made. If not specified, the method will use all the
   *                                     keys from the object.
   * @param {Array}  [exclude=[]]        A list of keys or paths where the transformation won&apos;t
   *                                     be made.
   * @param {string} [pathDelimiter=&apos;.&apos;] The delimiter that will separate the path components
   *                                     for both `include` and `exclude`.
   * @return {Object}
   */
  static dashToSnakeKeys(target, include = [], exclude = [], pathDelimiter = &apos;.&apos;) {
    return this.formatKeys(
      target,
      /([a-z])-([a-z])/g,
      (fullMatch, firstLetter, secondLetter) =&gt; `${firstLetter}_${secondLetter}`,
      include,
      exclude,
      pathDelimiter
    );
  }
}

module.exports = ObjectUtils;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
