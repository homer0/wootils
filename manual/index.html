<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | wootils</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A set of Javascript utilities for building Node and browser apps."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="wootils"><meta property="twitter:description" content="A set of Javascript utilities for building Node and browser apps."></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/wootils"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html" data-ice="link">AppConfiguration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#loading-configurations-dynamically" data-ice="link">Loading configurations dynamically</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#using-it-without-environment-variables-" data-ice="link">Using it without environment variables.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#extending-configurations" data-ice="link">Extending configurations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#get-and-set" data-ice="link">Get and Set</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#reading" data-ice="link">Reading</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#writing" data-ice="link">Writing</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#switching-configurations-while-the-app-is-running" data-ice="link">Switching configurations while the app is running</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html" data-ice="link">EnvironmentUtils</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#read" data-ice="link">Read</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#write" data-ice="link">Write</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#reading-variables" data-ice="link">Reading variables</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#writing-variables" data-ice="link">Writing variables</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#validating-variables" data-ice="link">Validating variables</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#environment-type-validation" data-ice="link">Environment type validation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html" data-ice="link">ErrorHandler</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/logger.html"><a href="manual/logger.html" data-ice="link">Logger</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/logger.html"><a href="manual/logger.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/logger.html"><a href="manual/logger.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#colored-messages" data-ice="link">Colored messages</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#multiple-messages-at-once" data-ice="link">Multiple messages at once</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#prefix" data-ice="link">Prefix</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#date-and-time" data-ice="link">Date and Time</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#applogger" data-ice="link">appLogger</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/logger.html"><a href="manual/logger.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html" data-ice="link">packageInfo</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html" data-ice="link">PathUtils</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#build-paths-relative-to-the-project-root-directory" data-ice="link">Build paths relative to the project root directory</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#multiple-locations" data-ice="link">Multiple locations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html" data-ice="link">rootRequire</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/APIClient.html"><a href="manual/APIClient.html" data-ice="link">APIClient</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/APIClient.html"><a href="manual/APIClient.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/APIClient.html"><a href="manual/APIClient.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/APIClient.html"><a href="manual/APIClient.html#configurable-endpoints" data-ice="link">Configurable endpoints</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#endpoint-objects" data-ice="link">Endpoint objects</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#sub-collections-of-endpoints" data-ice="link">Sub collections of endpoints</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#built-in-request-methods" data-ice="link">Built-in request methods</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#default-headers" data-ice="link">Default headers</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#authorization-token" data-ice="link">Authorization token</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/APIClient.html"><a href="manual/APIClient.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/deferred.html"><a href="manual/deferred.html" data-ice="link">deferred</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/deferred.html"><a href="manual/deferred.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/deferred.html"><a href="manual/deferred.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html" data-ice="link">EventsHub</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#listen-and-emit" data-ice="link">Listen and emit</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#reduce-a-variable" data-ice="link">Reduce a variable</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html" data-ice="link">ObjectUtils</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-merge--code-" data-ice="link">merge</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-copy--code-" data-ice="link">copy</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-get--code-" data-ice="link">get</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-set--code-" data-ice="link">set</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-extract--code-" data-ice="link">extract</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-delete--code-" data-ice="link">delete</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-flat--code-" data-ice="link">flat</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-unflat--code-" data-ice="link">unflat</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#-code-formatkeys--code-" data-ice="link">formatKeys</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/objectUtils.html"><a href="manual/objectUtils.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/simpleStorage.html"><a href="manual/simpleStorage.html" data-ice="link">SimpleStorage</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/simpleStorage.html"><a href="manual/simpleStorage.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simpleStorage.html"><a href="manual/simpleStorage.html#basic" data-ice="link">Basic</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simpleStorage.html"><a href="manual/simpleStorage.html#working-with-entries" data-ice="link">Working with entries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/simpleStorage.html"><a href="manual/simpleStorage.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>AppConfiguration</h1><p>This is a service to manage applications configurations. It takes care of loading, activating, switching and merging configuration files.</p><p>Managing configurations is always a pain on any kind of app, so the idea of this service is to just give it the minimal required information and it will take care of the rest.</p><h2>Example</h2><p>Let&apos;s say your app tree looks like this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>And you execute your app with something like</p><pre><code class="lang-bash"><code class="source-code prettyprint">node app</code>
</code></pre><p>If you don&apos;t have anything managing the configurations, you would probably have something like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">const config = process.NODE_ENV === &apos;production&apos; ?
  require(&apos;../config/production&apos;) :
  require(&apos;../config/development&apos;);</code>
</code></pre><p>Maybe is different, but the point is that you may be checking the <code>NODE_ENV</code> to decide what to <code>require</code>.</p><p>Let&apos;s implement the same scenario with <code>AppConfiguration</code>:</p><blockquote>
<p>The service depends on <code>EnvironmentUtils</code> and <code>RootRequire</code> (which requires <code>PathUtils</code>) so you need to register them first.</p>
</blockquote><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Since Jimple solves the construction of the dependencies, this will be more of a <em>manual process</em>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  AppConfiguration,
  EnvironmentUtils,
  PathUtils,
  rootRequire,
} = require(&apos;wootils/node&apos;);

// Let&apos;s start with `EnvironmentUtils`, which is used to read the env variables.
const environmentUtils = new EnvironmentUtils();
// Now `PathUtils`, to build paths relative to the project root directory.
const pathUtils = new PathUtils();
// `rootRequire` for making `require`s relatives to the root directory.
const rootReq = rootRequire(pathUtils);</code>
</code></pre><p>With all the needed services ready, let&apos;s construct the <code>AppConfiguration</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const appConfiguration = new AppConfiguration(
  environmentUtils,
  rootReq,
  &apos;myApp&apos;,
  {},
  {
    environmentVariable: &apos;CONFIG&apos;,
    path: &apos;./config/&apos;,
    filenameFormat: &apos;[name].js&apos;,
  },
);</code>
</code></pre><p>Done, we first sent the required services and then set the custom options we needed:</p><ol>
<li><code>myApp</code> is the name of the app, the service uses it on the default <code>path</code> and <code>filenameFormat</code> options, but in this case, we don&apos;t really need it for this scenario.</li>
<li><code>{}</code> That&apos;s the default configuration all the others will <em>&apos;extend&apos;</em>, in this case is not needed.</li>
<li>The options:<ul>
<li><code>environmentVariable</code>: The name of the variable the service will check to determine which configuration to use.</li>
<li><code>path</code>: The location of your configuration files.</li>
<li><code>filenameFormat</code>: The name format your files use. <code>[name]</code> will be replaced with the name of the configuration you want to use.</li>
</ul>
</li>
</ol><p>Now, there&apos;s only one thing to do:</p><pre><code class="lang-js"><code class="source-code prettyprint">appConfiguration.loadFromEnvironment();</code>
</code></pre><p>With that, <code>AppConfiguration</code> will check the environment variable and load the configuration you require.</p><pre><code class="lang-bash"><code class="source-code prettyprint"># Load the development configuration
CONFIG=development node app

# Load the production configuration
CONFIG=production node app</code>
</code></pre><h3>With Jimple</h3><p>Let&apos;s create a dummy app and register the dependencies:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const {
  environmentUtils,
  rootRequire,
  pathUtils,
  appConfiguration,
} = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the necessary services
app.register(environmentUtils);
app.register(rootRequire);
app.register(pathUtils);</code>
</code></pre><p>Now, to generate the <code>appConfiguration</code> service with the required settings to work with the scenario described above:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myConfiguration = appConfiguration(
  &apos;myApp&apos;,
  {},
  {
    environmentVariable: &apos;CONFIG&apos;,
    path: &apos;./config/&apos;,
    filenameFormat: &apos;[name].js&apos;,
  },
);
app.register(myConfiguration);</code>
</code></pre><p>Done, the service is registered in the container. Let&apos;s explain a little bit why <em>&apos;those&apos;</em> parameters:</p><ol>
<li><code>myApp</code> is the name of the app, the service uses it on the default <code>path</code> and <code>filenameFormat</code> options, but in this case, we don&apos;t really need it for this scenario.</li>
<li><code>{}</code> That&apos;s the default configuration all the others will <em>&apos;extend&apos;</em>, in this case is not needed.</li>
<li>The options:<ul>
<li><code>environmentVariable</code>: The name of the variable the service will check to determine which configuration to use.</li>
<li><code>path</code>: The location of your configuration files.</li>
<li><code>filenameFormat</code>: The name format your files use. <code>[name]</code> will be replaced with the name of the configuration you want to use.</li>
</ul>
</li>
</ol><p>Now, there&apos;s only one thing to do:</p><pre><code class="lang-js"><code class="source-code prettyprint">app.get(&apos;appConfiguration&apos;).loadFromEnvironment();</code>
</code></pre><p>With that, <code>AppConfiguration</code> will check the environment variable and load the configuration you require.</p><pre><code class="lang-bash"><code class="source-code prettyprint"># Load the development configuration
CONFIG=development node app

# Load the production configuration
CONFIG=production node app</code>
</code></pre><h2>Features</h2><h3>Loading configurations dynamically</h3><p>This was demonstrated on the example above. Instead of you having to manually check and indicate which file to <code>require</code>, <code>AppConfiguration</code> will handle the environment variable and the <code>require</code>, so once you do <code>loadFromEnvironment()</code> you get the configuration you need.</p><h3>Using it without environment variables.</h3><p>This is not the most common case of use, but <code>AppConfiguration</code> allows you to manually load new configurations from an object or from a file:</p><pre><code class="lang-js"><code class="source-code prettyprint">...
appConfiguration.load(&apos;my-new-config&apos;, { valueOne: &apos;one&apos; });</code>
</code></pre><p>or</p><pre><code class="lang-js"><code class="source-code prettyprint">appConfiguration.loadFromFile(&apos;my-new-config&apos;);
// And if you used the options from the example, it will load `/config/my-new-config.js`,
// or at least try :P.</code>
</code></pre><p>The idea of these methods is that if you don&apos;t want to relay on environment variables, you can build your own logic for loading and activating configurations.</p><h3>Extending configurations</h3><p>By default, all the configurations extend from the default one you sent on the constructor, but you can set an <code>extend</code> key on your configurations with the name of the one you want to extend and the service will take care of looking for that configuration and making the new one extend from there.</p><p>If you are using <code>loadFromEnvironment()</code> or <code>loadFromFile()</code> and the configuration to extend is not registered in the service, it will try to load the file; but if you are using <code>load()</code>, the configuration needs to be registered or it will throw an error. It doesn&apos;t sound nice, but the point is to make clear that you are either working with files or with manual configurations.</p><h3>Get and Set</h3><p>Your configuration is not longer a literal object and the service provides a couple of methods to make your life easy when reading or writing settings:</p><h4>Reading</h4><pre><code class="lang-js"><code class="source-code prettyprint">// Read a single setting
const value = appConfiguration.get(&apos;something&apos;);
// Reading multiple settings
const { valueOne, valueTwo } = appConfiguration.get([&apos;valueOne&apos;, &apos;valueTwo&apos;]);</code>
</code></pre><h4>Writing</h4><blockquote>
<p>The changes won&apos;t affect a configuration file, they&apos;ll only affect the configuration loaded on the service.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">// Writing a single setting
appConfiguration.set(&apos;something&apos;, &apos;value&apos;);
// Write multiple settings
appConfiguration.write({
  valueOne: &apos;one&apos;,
  valueTwo: &apos;two&apos;,
});</code>
</code></pre><p>Another cool thing it does is when it writes a setting, if both the current and the new values are both Objects, it will merge them:</p><pre><code class="lang-js"><code class="source-code prettyprint">appConfiguration.set(&apos;person&apos;, {
  name: &apos;Rosario&apos;,
  birthday: &apos;&apos;,
});
appConfiguration.set(&apos;person&apos;, {
  birthday: &apos;25-09-2015&apos;,
});
console.log(appConfiguration.get(&apos;person&apos;));
/**
 * Will output:
 * {
 *   name: &apos;Rosario&apos;,
 *   birthday: &apos;25-09-2015&apos;,
 * }
 */</code>
</code></pre><h3>Switching configurations while the app is running</h3><p>There&apos;s a special rule behind this feature: The default configuration and/or the first configuration loaded needs to have a key name <code>allowConfigurationSwitch</code> set to <code>true</code> in order switch configurations. The reason of this rule is <strong>security</strong>: If you deployed to production and the you didn&apos;t turn off whatever you have that makes the service switch configurations, other people can use it. This way, you can have this enabled only on specifics configuration and disabled on others.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/appConfiguration.js~AppConfiguration.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/appConfiguration.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>EnvironmentUtils</h1><p>A really small service to centralize the place where you read and write environment variables, and check if you are running on development or production.</p><p>Is not uncommon nowadays for Node apps to be checking <code>NODE_ENV</code> and other environment variables in order to do or not to do certain things, and having multiple calls to <code>process.env</code> on different places of your app may not be a good idea: It&apos;s hard to track and maintain.</p><h2>Examples</h2><h3>Read</h3><p>Let&apos;s say your code looks something like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">if (process.env.NODE_ENV !== &apos;production&apos;) {
  addSomeStuffForDevelopment();
}

console.log(`Hello ${process.env.NAME}`);</code>
</code></pre><p>Let&apos;s implement the same but with <code>EnvironmentUtils</code>:</p><h4>Without Jimple</h4><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { EnvironmentUtils } = require(&apos;wootils/node&apos;);
// Construct an instance.
const environmentUtils = new EnvironmentUtils();</code>
</code></pre><p>Now, to update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">if (environmentUtils.development) {
  addSomeStuffForDevelopment();
}
// The service allows you to set a default in case the variable is not defined.
const name = environmentUtils.get(&apos;NAME&apos;, &apos;Rosario&apos;);
console.log(`Hello ${name}`);</code>
</code></pre><p>Done! Now you are not manually checking for <code>NODE_ENV</code> and all your variables are being read on a single place.</p><h4>With Jimple</h4><p>Let&apos;s setup a dummy app and register the service:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { environmentUtils } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();

app.register(environmentUtils);</code>
</code></pre><p>Now, to update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">// The imported provider has the same name, that&apos;s why I called it `envUtils`.
const envUtils = app.get(&apos;environmentUtils&apos;);
if (envUtils.development()) {
  addSomeStuffForDevelopment();
}
// The service allows you to set a default in case the variable is not defined.
const name = envUtils.get(&apos;NAME&apos;, &apos;Rosario&apos;);
console.log(`Hello ${name}`);</code>
</code></pre><p>Done! Now you are not manually checking for <code>NODE_ENV</code> and all your variables are being read on a single place.</p><h3>Write</h3><p>Ok, writing on the environment from inside an application is not that common as reading, but there are certain cases where this may come in handy.</p><p>Let&apos;s say you are using a library that has a <em>&quot;debug mode&quot;</em> but the only way to enable it is using a environment variable, and for &quot;purposes of debugging&quot;, you want to do it from your code:</p><pre><code class="lang-js"><code class="source-code prettyprint">process.env.DEBUG_MY_LIBRARY = &apos;true&apos;;
runMyMagicLibrary();</code>
</code></pre><p>Like for <code>get</code>, <code>set</code> also allows you to centralize where you overwrite your environment variables, but at the same time, it protects you from overwriting something that is already declared: Unless you tell <code>set</code> to overwrite declarations, if the variable already exists, it won&apos;t do it.</p><h4>Without Jimple</h4><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { EnvironmentUtils } = require(&apos;wootils/node&apos;);
// Construct an instance.
const environmentUtils = new EnvironmentUtils();</code>
</code></pre><p>Now, to update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">// If you add a third parameter with `true`, it will overwrite any previous declaration.
const name = environmentUtils.set(&apos;DEBUG_MY_LIBRARY&apos;, &apos;true&apos;);
runMyMagicLibrary();</code>
</code></pre><p>Done! Now you are not manually updating the environment variable and potentially overwriting something that was already declared.</p><h4>With Jimple</h4><p>Let&apos;s setup a dummy app and register the service:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { environmentUtils } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();

app.register(environmentUtils);</code>
</code></pre><p>Now, to update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">// The imported provider has the same name, that&apos;s why I called it `envUtils`.
const envUtils = app.get(&apos;environmentUtils&apos;);
// If you add a third parameter with `true`, it will overwrite any previous declaration.
const name = envUtils.set(&apos;DEBUG_MY_LIBRARY&apos;, &apos;true&apos;);
runMyMagicLibrary();</code>
</code></pre><p>Done! Now you are not manually updating the environment variable and potentially overwriting something that was already declared.</p><h2>Features</h2><h3>Reading variables</h3><p>This was demonstrated on the first example. You just need to <code>.get()</code> with the name of the variable you want to read.</p><h3>Writing variables</h3><p>This was demostrated on the second example. You just need to <code>.set()</code> with the name and the value for the variable.</p><h3>Validating variables</h3><p>You can call <code>.exists()</code> with the name of the variable and the service will tell you if it&apos;s defined on the environment.</p><h3>Environment type validation</h3><p>No more <code>if (process.env.NODE_ENV ...</code>, <code>EnvironmentUtils</code> does it once when you instantiate it and then gives you <code>production()</code> and <code>development()</code> for you to use.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/environmentUtils.js~EnvironmentUtils.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/environmentUtils.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>ErrorHandler</h1><p>Listens for uncaught exceptions and unhandled promises rejections, and logs them out with full detail.</p><p>By default, if an error is thrown, node will just output the error, but if a <code>Promise</code> is rejected and there&apos;s no <code>catch</code> to capture the exception, it will log <code>...</code>, which doesn&apos;t provide a lot of information, right?</p><p>Well, <code>ErrorHandler</code> listens for these kind of exceptions, unhandled errors and rejected promises, and logs them with their stack trace information using the <code>Logger</code> utility.</p><h2>Example</h2><p>Let&apos;s say your code looks something like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">makeAnAPICall()
.then((response) =&gt; console.log(response));</code>
</code></pre><p>If the request returned a <code>401</code>, Node would output something like this:</p><pre><code class="lang-bash"><code class="source-code prettyprint">(node:34097) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): 401</code>
</code></pre><p>Now, let&apos;s see how to get more information with <code>ErrorHandler</code>:</p><blockquote>
<p>The service depends on a <code>Logger</code> service instance, so you need to register it first.</p>
</blockquote><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><blockquote>
<p>All of this code should be added on top of the already existing code showed above.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger, ErrorHandler } = require(&apos;wootils/node&apos;);
// Create an instance of the logger service
const logger = new Logger();
// Create an instance of the handler
const errorHandler = new ErrorHandler(logger);</code>
</code></pre><p>Now, once you have the instance, you have to tell it to start listening for unhandled errors:</p><pre><code class="lang-js"><code class="source-code prettyprint">errorHandler.listen();</code>
</code></pre><p>Done! If you run the same code now, this is the kind of logged information you&apos;ll get:</p><pre><code class="lang-bash"><code class="source-code prettyprint">[2018-01-22 04:19:12] 401
at makeAPICall (/path-to-your-app/index.js:9:42)
at Object.&lt;anonymous&gt; (/path-to-your-app/index.js:11:1)
at Module._compile (module.js:570:32)
at Object.Module._extensions..js (module.js:579:10)
at Module.load (module.js:487:32)
at tryModuleLoad (module.js:446:12)
at Function.Module._load (module.js:438:3)
at Module.runMain (module.js:604:10)
at run (bootstrap_node.js:383:7)
at startup (bootstrap_node.js:149:9)</code>
</code></pre><p>You get the date and time when it happened and the full stack trace of the error.</p><h3>With Jimple</h3><p>When used with Jimple, instead of using the <code>logger</code> service, it uses the <code>logger</code> service:</p><blockquote>
<p>It uses <code>logger</code> by default, but if the service is not available, it will try to fallback to <code>appLogger</code>, the alternative version of <code>logger</code> that prefixes all the messages with the project name.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const {
  logger,
  errorHandler,
} = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(logger);
// Register the ErrorHandler
app.register(errorHandler);</code>
</code></pre><p>Now, we should tell the service to start listening for errors:</p><pre><code class="lang-js"><code class="source-code prettyprint">app.get(&apos;errorHandler&apos;).listen();</code>
</code></pre><p>Done! If you run the same code now, this is the kind of logged information you&apos;ll get:</p><pre><code class="lang-bash"><code class="source-code prettyprint">[my-app] [2018-01-22 04:29:40] 401
[my-app] at makeAPICall (/path-to-your-app/index.js:9:42)
[my-app] at Object.&lt;anonymous&gt; (/path-to-your-app/index.js:11:1)
[my-app] at Module._compile (module.js:570:32)
[my-app] at Object.Module._extensions..js (module.js:579:10)
[my-app] at Module.load (module.js:487:32)
[my-app] at tryModuleLoad (module.js:446:12)
[my-app] at Function.Module._load (module.js:438:3)
[my-app] at Module.runMain (module.js:604:10)
[my-app] at run (bootstrap_node.js:383:7)
[my-app] at startup (bootstrap_node.js:149:9)</code>
</code></pre><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/errorHandler.js~ErrorHandler.html">online</a> and generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/errorHandler.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Logger</h1><p>The name leaves nothing to the imagination. As you may have guessed, this is service for logging messages into the console.</p><p>It&apos;s not uncommon for Node apps to be logging information into the console all the time: success messages, warnings and even errors; and if you don&apos;t have an already implemented solution for logging, you are probably calling <code>console.[log|info|error]</code> on a bunch of places, which is probably not a great thing to do.</p><p><code>Logger</code> is not a super complete logging system with multiple logging levels and stuff like that, it&apos;s just a simple tool for logging colored messages on the console. </p><h2>Example</h2><p>Let&apos;s say you scenarios like these:</p><pre><code class="lang-js"><code class="source-code prettyprint">console.log(&apos;Starting the app&apos;);

if (usingExperimentalFeature()) {
  console.log(&apos;WARNING: This feature is experimental&apos;);
}

if (onDevelopment()) {
  console.log(&apos;Running on a development environment&apos;);
}

if (loadConfiguration()) {
  console.log(&apos;The configuration was successfully loaded&apos;);
}

try {
  methodThatMayThrowAnError();
} catch (error) {
  console.log(&apos;Damn it!&apos;, error);
}</code>
</code></pre><p>Now, let&apos;s see how to implement the same messages with <code>Logger</code>:</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><blockquote>
<p>All of this code should be added on top of the already existing code showed above.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger } = require(&apos;wootils/node&apos;);
// Create an instance
const logger = new Logger();</code>
</code></pre><p>Now let&apos;s update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">logger.log(&apos;Starting the app&apos;);
// Will log the message the same way `console.log` would.

if (usingExperimentalFeature()) {
  logger.warning(&apos;WARNING: This feature is experimental&apos;);
  // Will log a yellow message.
}

if (onDevelopment()) {
  logger.info(&apos;Running on a development environment&apos;);
  // Will log a gray message.
}

if (loadConfiguration()) {
  logger.success(&apos;The configuration was successfully loaded&apos;);
  // Will log a green message
}

try {
  methodThatMayThrowAnError();
} catch (error) {
  logger.error(&apos;Damn it!&apos;, error);
  // Will log `Damn it!` on read and the `error` stack trace information on `gray`.
}</code>
</code></pre><p>Done, with that your app is now logging the messages with a color referencing the type of message.</p><h3>With Jimple</h3><p>Let&apos;s setup a dummy app and register the service:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { logger } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(logger);</code>
</code></pre><p>Now let&apos;s update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">// The imported provider is called `logger`, that&apos;s why I named the variable `log`.
const log = app.get(&apos;logger&apos;);

log.log(&apos;Starting the app&apos;);
// Will log the message the same way `console.log` would.

if (usingExperimentalFeature()) {
  log.warning(&apos;WARNING: This feature is experimental&apos;);
  // Will log a yellow message.
}

if (onDevelopment()) {
  log.info(&apos;Running on a development environment&apos;);
  // Will log a gray message.
}

if (loadConfiguration()) {
  log.success(&apos;The configuration was successfully loaded&apos;);
  // Will log a green message
}

try {
  methodThatMayThrowAnError();
} catch (error) {
  logger.error(&apos;Damn it!&apos;, error);
  // Will log `Damn it!` on read and the `error` stack trace information on `gray`.
}</code>
</code></pre><p>Done, with that your app is now logging the messages with a color referencing the type of message.</p><h2>Features</h2><h3>Colored messages</h3><p>This was demonstrated on the example above:</p><ol>
<li><code>success(message)</code> will log a green message.</li>
<li><code>warning(message)</code> will log a yellow message.</li>
<li><code>error(message)</code> will log a red message.</li>
<li><code>info(message)</code> will log a gray message.</li>
</ol><p>But they all depend on this method:</p><p><code>log(message, color)</code> allows you to specify one of the colors available on the <a href="https://yarnpkg.com/en/package/colors"><code>colors</code></a> package. By default, it uses the console default text color.</p><h3>Multiple messages at once</h3><p>All the methods support both a single message or an <code>Array</code> of them:</p><pre><code class="lang-js"><code class="source-code prettyprint">logger.info([&apos;App running&apos;, &apos;connection detected&apos;, &apos;starting Skynet...&apos;]);
// This will log three gray messages.</code>
</code></pre><p>You can even specify a color for each message:</p><pre><code class="lang-js"><code class="source-code prettyprint">logger.success([
  &apos;It works!&apos;,
  [&apos;wait, something is happening&apos;, &apos;gray&apos;],
  &apos;Nevermind, Skynet is up and running!&apos;,
]);
// This will log the first and third message on green and the second one on gray.</code>
</code></pre><h3>Prefix</h3><p>When constructing the service or when generating the provider, you can specify a <code>prefix</code> that will be added to every message:</p><h4>Without Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger } = require(&apos;wootils/node&apos;);
// Create an instance
const logger = new Logger(&apos;my-app&apos;);

logger.success(&apos;The instance was created!&apos;);
// This will log `[my-app] The instance was created!` on green.</code>
</code></pre><h4>With Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { loggerWithOptions } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(loggerWithOptions(&apos;my-app&apos;));

app.get(&apos;logger&apos;).success(&apos;The instance was created!&apos;);
// This will log `[my-app] The instance was created!` on green.</code>
</code></pre><h3>Date and Time</h3><p>When constructing the service or when generating the provider, you can specify whether or not you would like to show the date and time on every message. By default, it only does it for errors:</p><h4>Without Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger } = require(&apos;wootils/node&apos;);
// Create an instance
const logger = new Logger(&apos;my-app&apos;, true);

logger.success(&apos;The instance was created!&apos;);
// This will log `[my-app][YYYY-MM-DD HH:MM:SS] The instance was created!` on green.</code>
</code></pre><h4>With Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { loggerWithOptions } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(loggerWithOptions(&apos;my-app&apos;, true));

app.get(&apos;logger&apos;).success(&apos;The instance was created!&apos;);
// This will log `[my-app][YYYY-MM-DD HH:MM:SS] The instance was created!` on green.</code>
</code></pre><h3>appLogger</h3><p>This is only for Jimple implementations. <code>appLogger</code> is a service provider that uses the service <code>packageInfo</code> to obtain the app name from the <code>package.json</code> and automatically use it as the <code>prefix</code> for every message.</p><p>Let&apos;s say the <code>name</code> of your app on your <code>package.json</code> is <code>skynet</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { appLogger } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(appLogger);

app.get(&apos;appLogger&apos;).success(&apos;The instance was created!&apos;);
// This will log `[skynet] The instance was created!` on green.</code>
</code></pre><p>There&apos;s also <code>appLoggerWithOptions</code> that allows you to enable or disabled the date and time for the messages.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/logger.js~Logger.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/logger.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>packageInfo</h1><p>A tiny function that reads the contents of the app <code>package.json</code>. This is really useful on an Jimple application where you can register it, because the returned value gets cached and it&apos;s available as a service.</p><h2>Example</h2><p>Even if the function is really small (one line to be exact), it has a dependency: <code>PathUtils</code>. It uses it to build the path to the <code>package.json</code> relative to the project root directory.</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { PathUtils, packageInfo } = require(&apos;wootils/node&apos;);
// Create an instance of the dependency.
const pathUtils = new PathUtils();

// Now, let&apos;s use the function
const packageJson = packageInfo(pathUtils);</code>
</code></pre><p>Done, <code>packageJson</code> now has all the contents of your <code>package.json</code>, as an Object.</p><h3>With Jimple</h3><p>First, let&apos;s setup a dummy app and register the dependency and the service itself:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { pathUtils, packageInfo } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the dependency
app.register(pathUtils);
// Register the service
app.register(packageInfo);</code>
</code></pre><p>Now, to use it:</p><pre><code class="lang-js"><code class="source-code prettyprint">const packageJson = app.get(&apos;packageInfo&apos;);</code>
</code></pre><p>Done, <code>packageJson</code> now has all the contents of your <code>package.json</code>, as an Object; and the file won&apos;t be read more than once.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/function/index.html#static-function-packageInfo">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/packageInfo.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>PathUtils</h1><p>An easy way to manage locations and build paths relative to those locations on a Node app.</p><p>When writing static <code>require</code> statements is easy: The file you are requiring is relative to the one where you are writing the <code>require</code>. But when you are reading files or doing <code>require</code> with dynamic paths, it can get messy pretty fast, and that&apos;s where this utility shines.</p><h2>Example</h2><p>Let&apos;s say your app tree looks like this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>And you want to access <code>config/development.js</code>, but when you build your app, or prepare it to deployment, it becomes this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; dist/
&#x2502;   &#x2514;&#x2500;&#x2500; app/
&#x2502;       &#x2514;&#x2500;&#x2500; index.min.js
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>There&apos;s a lot of ways to check whether you need to call <code>../config</code> or <code>../../config</code>: <code>TryCatch</code>, check some environment variable, check if <code>../config</code> exists, etc. Well, with <code>PathUtils</code>, you don&apos;t need to do that, because the service knowns that if you ask for <code>config/development.js</code>, it&apos;s relative to your project root directory.</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">// Require the class.
const { PathUtils } = require(&apos;wootils/node&apos;);
// Instantiate it.
const pathUtils = new PathUtils();</code>
</code></pre><p>Now that you have the service instance, getting the path is easy as:</p><pre><code class="lang-js"><code class="source-code prettyprint">const devConfigPath = pathUtils.join(&apos;config/development&apos;);</code>
</code></pre><p>Done, now you can use either <code>require</code> or <code>fs</code> to get the contents of the file.</p><h3>With Jimple</h3><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { pathUtils } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the service
app.register(pathUtils);</code>
</code></pre><p>Now that you have the service instance, getting the path is easy as:</p><pre><code class="lang-js"><code class="source-code prettyprint">const devConfigPath = app.get(&apos;pathUtils&apos;).join(&apos;config/development&apos;);</code>
</code></pre><p>Done, now you can use either <code>require</code> or <code>fs</code> to get the contents of the file.</p><h2>Features</h2><h3>Build paths relative to the project root directory</h3><p>This was demonstrated on the example above. The <code>join</code> method works exactly like <code>path.join</code>, you can send any number of parameters and they will be merged on one single path.</p><pre><code class="lang-js"><code class="source-code prettyprint">pathUtils.join(&apos;config&apos;, &apos;development.js&apos;);
// is the same as
pathUtils.join(&apos;config/development.js&apos;);</code>
</code></pre><h3>Multiple locations</h3><p>By default, <code>PathUtils</code> uses the <code>home</code> location, which is the project root directory, but it also has an <code>app</code> location and the ability to register new locations:</p><p>The <code>app</code> location is the directory where your app executable file is located, for the project tree used on the example above, the <code>app</code> location is <code>/app</code> on development, and <code>/dist/app</code> when builded/deployed.</p><p>To register new locations, you use the <code>addLocation</code> method:</p><pre><code class="lang-js"><code class="source-code prettyprint">pathUtils.addLocation(&apos;my-location&apos;, &apos;some-folder/some-sub-folder&apos;);</code>
</code></pre><p>The new location path <strong>must</strong> be relative to your project root directory.</p><p>And finally, to use those locations, you use <code>joinFrom</code> instead of <code>join</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const pathToFile = pathUtils.joinFrom(&apos;my-location&apos;, &apos;some-file.js&apos;);</code>
</code></pre><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/pathUtils.js~PathUtils.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/pathUtils.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>rootRequire</h1><p>Is basically <code>require</code> but the path is relative to the project root directory.</p><p>This is very useful when working with dynamic <code>require</code> statements and project that when bundled or deployed change locations.</p><h2>Example</h2><p>Let&apos;s say your app tree looks like this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>And you want to access <code>config/development.js</code>, but when you build your app, or prepare it to deployment, it becomes this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; dist/
&#x2502;   &#x2514;&#x2500;&#x2500; app/
&#x2502;       &#x2514;&#x2500;&#x2500; index.min.js
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>There&apos;s a lot of ways to check whether you need to call <code>../config</code> or <code>../../config</code>: <code>TryCatch</code>, check some environment variable, check if <code>../config</code> exists, etc.  Well, with <code>rootRequire</code>, you don&apos;t need to do that, because the service knowns that if you ask for <code>config/development.js</code>, it&apos;s relative to your project root directory.</p><p>Now, before taking a look a how we would implement this with root require, the function, even as small as it is, it has a dependency: <code>PathUtils</code>. It uses it to build the paths relative to the project root directory.</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { PathUtils, rootRequire } = require(&apos;wootils/node&apos;);
// Create an instance of the dependency.
const pathUtils = new PathUtils();

// Now, let&apos;s generate the function
const rootReq = rootRequire(pathUtils);
// And finally use it to get the file
const config = rootReq(&apos;config/development&apos;);</code>
</code></pre><p>Done, <code>config</code> now has the contents of <code>config/development</code>, and this will work no matter where the app file is located.</p><h3>With Jimple</h3><p>First, let&apos;s setup a dummy app and register the dependency and the service itself:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { pathUtils, rootRequire } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the dependency
app.register(pathUtils);
// Register the service
app.register(rootRequire);</code>
</code></pre><p>Now, to use it:</p><pre><code class="lang-js"><code class="source-code prettyprint">const config = app.get(&apos;rootRequire&apos;)(&apos;config/development&apos;);</code>
</code></pre><p>Done, <code>config</code> now has the contents of <code>config/development</code>, and this will work no matter where the app file is located.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/function/index.html#static-function-rootRequire">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/rootRequire.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>APIClient</h1><p>A really basic client to work with an API endpoints requests.</p><p>Nowadays there&apos;s almost no app that doesn&apos;t make requests to one or more external APIs, that&apos;s why I built this service.</p><p>Now, the reason this is marked as <em>&apos;shared&apos;</em> it&apos;s because it basically organizes the API configuration and prepares the requests, but you have to give it a <code>fetch</code> client to make the request. It&apos;s <em>&apos;shared&apos;</em> because on a browser you can give it the native <code>fetch</code> function, and on Node, something like <code>node-fetch</code> or <code>axios</code>, but that supports the native <code>fetch</code> signature.</p><h2>Examples</h2><blockquote>
<p>This example will be on Node, so I&apos;ll use <a href="https://yarnpkg.com/en/package/node-fetch"><code>node-fetch</code></a> as fetch client.</p>
</blockquote><p>First, let&apos;s start by creating the configuration:</p><pre><code class="lang-js"><code class="source-code prettyprint">const url = &apos;https://my-api.com&apos;;
const endpoints: {
  login: &apos;auth/login&apos;,
  profile: &apos;users/:userId&apos;,
  users: &apos;users&apos;,
};
const fetchClient = require(&apos;node-fetch&apos;);</code>
</code></pre><p>You need those three things to instantiate the client:</p><ol>
<li>An entry point for your API.</li>
<li>A dictionary of endpoints (Check the <strong>features</strong> section to see all the possible ways to define an endpoint).</li>
<li>A fetch client to make the requests.</li>
</ol><p>Now, to instantiate the client:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { APIClient } = require(&apos;wootils/shared&apos;);

const client = new APIClient(url, endpoints, fetchClient);</code>
</code></pre><p>To make a request, you first need to generate an endpoint and use it to call the method of the type of request you want to make.</p><p>Let&apos;s say you want to authenticate a user, which is a <code>POST</code> request to the <code>login</code> endpoint with a body that includes <code>username</code> and <code>password</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.post(client.endpoint(&apos;login&apos;), {
  username: &apos;Rosario&apos;,
  password: &apos;charito&apos;,
})
.then((response) =&gt; {
  // Do something...
});</code>
</code></pre><p>Ok, that one was easy, no extra options or parameters. Next will request some user information from the <code>profile</code> endpoint, a <code>GET</code> request that requires a <code>userId</code> parameter:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.get(client.endpoint(&apos;profile&apos;, { userId: 2509 }), {
  username: &apos;Rosario&apos;,
  password: &apos;charito&apos;,
})
.then((response) =&gt; {
  // Do something...
});</code>
</code></pre><p>Easy enough, right? Well, for the last example, we&apos;ll make a request to get the users directory to the <code>users</code> endpoint, a <code>GET</code> request and we&apos;ll include a query string parameter to <em>&quot;limit the number of returned users&quot;</em>:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.get(client.endpoint(&apos;users&apos;, { count: 10 }), {
  username: &apos;Rosario&apos;,
  password: &apos;charito&apos;,
})
.then((response) =&gt; {
  // Do something...
});</code>
</code></pre><p>Done! If the parameter doesn&apos;t have a placeholder on the endpoint path, it gets automatically added on the query string.</p><h2>Features</h2><h3>Configurable endpoints</h3><p>On the example above, all the endpoints were strings, but you can define them as objects to include default query string parameters, or even as sub collections of endpoints:</p><h4>Endpoint objects</h4><pre><code class="lang-js"><code class="source-code prettyprint">const endpoints = {
  users: {
    path: &apos;users&apos;,
    query: {
      count: 10,
      offset: null,
    },
  },
};</code>
</code></pre><p>In that case, if <code>count</code> is not specified on <code>endpoint(...)</code>, it will have a default value of <code>10</code>.</p><p>And if <code>offset</code> is not specified, it won&apos;t be sent. The reason the configuration supports <em>&quot;nullable&quot;</em> parameters is so they can be used like some sort of documentation for the endpoint: <em>&quot;It&apos;s not used, but there&apos;s an optional parameter called ...&quot;</em>.</p><h4>Sub collections of endpoints</h4><pre><code class="lang-js"><code class="source-code prettyprint">const endpoints = {
  login: &apos;auth/login&apos;,
  users: {
    profile: &apos;users/:userId&apos;,
    directory: {
      path: &apos;users&apos;,
      query: {
        count: 10,
      },
    },
  },
};</code>
</code></pre><p>As you can see, both users related endpoints are now under <code>users</code>, and <code>login</code> is still on the top level. To access <em>&quot;sub endpoints&quot;</em> you use dot notation:</p><pre><code class="lang-js"><code class="source-code prettyprint">const endpointURL = client.endpoint(&apos;users.profile&apos;, { userId: 2509 });</code>
</code></pre><p>This allows you to organize the scopes of your endpoints and make the configuration easier to read.</p><h4>Built-in request methods</h4><p>On the example above we saw only <code>.get</code> and <code>.post</code>, but the client comes with these already built-in request methods:</p><ul>
<li><code>.get(url, options = {})</code></li>
<li><code>.head(url, options = {})</code></li>
<li><code>.post(url, body, options = {})</code></li>
<li><code>.put(url, body, options = {})</code></li>
<li><code>.patch(url, body, options = {})</code></li>
<li><code>.delete(url, body = {}, options = {})</code></li>
</ul><p>If you are wondering what <code>options</code> are, well, they are extra options for the <code>fetch</code> client call. It can include headers, another method, another body, etc. Everything that could send on the <code>fetch</code> call second parameter.</p><h4>Default headers</h4><p>The client allows you to set a dictionary of default headers you want to include on every request.</p><p>For example, let&apos;s say you are on a development environment and you want all your request to go out with the header <code>x-development</code> set to <code>true</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.setDefaultHeaders({
  &apos;x-development&apos;: true,
});</code>
</code></pre><p>Now, all the outgoing requests will include that header.</p><h4>Authorization token</h4><p>If you are working with an API that requires authorization on every requests, and that provides you with a bearer token when you authenticate, you could set it on the client and it will automatically include the <code>Authorization</code> header on every request and send the token:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.setAuthorizationToken(&apos;some-token&apos;);</code>
</code></pre><p>Done, all the requests will include <code>Authorization: Bearer some-token</code>.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/shared/apiClient.js~APIClient.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/APIClient.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>deferred</h1><p>Create a deferred promise using the native <code>Promise</code> object.</p><h2>Example</h2><p>Using it is really simple, you call the <code>deferred()</code> function and get an object with <code>promise</code>, <code>resolve</code> and <code>reject</code>. You return the <code>promise</code> property and then call <code>resolve</code> or <code>reject</code> to either resolve the promise or reject it.</p><p>Now, a reason to use this is for when you have another service/function/something asking for something that your code hasn&apos;t even started to do:</p><blockquote>
<p>I&apos;m using Node and <a href="https://yarnpkg.com/en/package/fs-extra"><code>fs-extra</code></a> because of the Promise based interface for <code>fs</code>.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">const fs = require(&apos;fs-extra&apos;);
const { deferred } = require(&apos;wootils/shared&apos;);

class MyServiceThatLoadsAfile {
  constructor() {
    this._defer = deferred();
    this._fileContents = null;
  }

  getFileContents() {
    return this._fileContents ?
      Promise.resolve(this._fileContents) :
      this._defer.promise;
  }

  loadTheFile() {
    return fs.readFile(&apos;some-path&apos;, &apos;utf-8&apos;)
    .then((contents) =&gt; {
      this._fileContents = contents;
      this.defer.resolve(contents);
    })
    .catch((error) =&gt; {
      this.defer.reject(error);
    });
  }
}

const myService = new MyServiceThatLoadsAfile();
myService.getFileContents()
.then((contents) =&gt; {
  console.log(&apos;GOT IT&apos;, contents);
});

// ...
myService.loadTheFile();</code>
</code></pre><p>Ok, there&apos;s a lot going on this example, let&apos;s break it:</p><ol>
<li><code>MyServiceThatLoadsAFile</code> creates a deferred promise on its constructor.</li>
<li><code>getFileContents</code> should return the file contents, but because the file is not loaded yet (because <code>loadTheFile</code> has not been called), it returns the deferred promise.</li>
<li>Eventually, <code>loadTheFile</code> gets called, it loads the file and either resolves or rejects the deferred promise, so the <code>getFileContents().then(...)</code> gets finally called.</li>
</ol><p>I wanted to keep the example small, but on a real app, <code>getFileContents</code> is probably called by other service that has no idea the instance was just created or that <code>loadTheFile</code> hasn&apos;t been called yet.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/function/index.html#static-function-deferred">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/deferred.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>EventsHub</h1><p>A small implementation of a pubsub service for handling events on an app.</p><p>It doesn&apos;t require any configuration or have customization options: You listen for an event with <code>on</code>, emit an event with <code>emit</code> and reduce a variable through an event with <code>reduce</code>.</p><h2>Examples</h2><p>First, let&apos;s create an instance of the hub:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { EventsHub } = require(&apos;wootils/shared&apos;);
const events = new EventsHub();</code>
</code></pre><h3>Listen and emit</h3><pre><code class="lang-js"><code class="source-code prettyprint">// Add the listener
events.on(&apos;my-event&apos;, () =&gt; {
  console.log(&apos;The event listener was called!&apos;);
});
// Emit the event
events.emit(&apos;my-event&apos;);</code>
</code></pre><p>Quite simple, right? You can also send any number of parameters to the events:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Add the listener
events.on(&apos;user-login&apos;, (username, password) =&gt; {
  someAuthService.login(username, password)
  .then((userInfo) =&gt; {
    events.emit(&apos;user-login-successfull&apos;, userInfo);
  })
  .catch((error) =&gt; {
       events.emit(&apos;user-login-failed&apos;, error);
  });
});

...

events.emit(&apos;user-login&apos;, &apos;rosario&apos;, &apos;p4ssword&apos;);</code>
</code></pre><p>And you can even use the same listener for multiple events:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Add the listener
events.on([&apos;logout-route&apos;, &apos;unauthorized-request&apos;], () =&gt; {
  someAuthService.signout();
});

...

events.emit(&apos;logout-route&apos;);
// or
someRequest()
.then(() =&gt; ... )
.catch((error) =&gt; {
  if (error.code === 401) {
    events.emit(&apos;unauthorized-request&apos;);
  }
})</code>
</code></pre><blockquote>
<p>All methods that support an event name also support an <code>Array</code> with a list of them.</p>
</blockquote><h3>Reduce a variable</h3><p>It&apos;s basically the same as calling <code>emit</code>, but the first parameter may be modified by the listeners and it&apos;s returned after it went through all of them.</p><pre><code class="lang-js"><code class="source-code prettyprint">events.on(&apos;filter-users-list&apos;, (list) =&gt; {
  list.splice(1, 1);
  return list;
});

const usersList = [&apos;charito&apos;, &apos;Rosario&apos;];
const newUsersList = events.reduce(&apos;filter-users-list&apos;, usersList);
console.log(newUsersList);
// Will log [&apos;charito&apos;]</code>
</code></pre><blockquote>
<p><code>reduce</code> also supports sending any number of parameters after the target variable.</p>
</blockquote><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/shared/eventsHub.js~EventsHub.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/eventsHub.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>ObjectUtils</h1><p>A small collection of utility methods to work with objects that relies on <a href="https://yarnpkg.com/en/package/extend"><code>extend</code></a> for deep merge and copy.</p><h2>Examples</h2><h3><code>merge</code></h3><p>Make a deep merge of a list of objects.</p><pre><code class="lang-js"><code class="source-code prettyprint">const objA = { a: &apos;first&apos; };
const objB = { b: &apos;second&apos; };

console.log(ObjectUtils.merge(objA, objB));
// Will output { a: &apos;first&apos;, b: &apos;second&apos; }</code>
</code></pre><h3><code>copy</code></h3><p>Make a deep copy of an object.</p><pre><code class="lang-js"><code class="source-code prettyprint">const objA = { a: &apos;first&apos; };
const objB = ObjectUtils.copy(objA);
objA.b = &apos;second&apos;;

console.log(objB);
// Will output { a: &apos;first&apos; }</code>
</code></pre><h3><code>get</code></h3><p>Read a property from an object using a path:</p><pre><code class="lang-js"><code class="source-code prettyprint">const obj = {
  propOne: {
    propOneSub: &apos;Charito!&apos;,
  },
  propTwo: &apos;!!!&apos;,
};

console.log(ObjectUtils.get(
  obj,
  &apos;propOne.propOneSub&apos;
));
// Will output &apos;Charito!&apos;</code>
</code></pre><h3><code>set</code></h3><p>Set a property on an object using a path. If the path doesn&apos;t exist, it will be created.</p><pre><code class="lang-js"><code class="source-code prettyprint">const target = {};

console.log(ObjectUtils.set(target, &apos;some.prop.path&apos;, &apos;some-value&apos;));
// Will output { some: { prop: { path: &apos;some-value&apos; } } }</code>
</code></pre><h3><code>extract</code></h3><p>Extracts a property or properties from an object in order to create a new one.</p><pre><code class="lang-js"><code class="source-code prettyprint">const target = {
  name: {
    first: &apos;Rosario&apos;,
  },
  age: 3,
  address: {
    planet: &apos;earth&apos;,
    something: &apos;else&apos;,
  },
};

console.log(ObjectUtils.set(obj, [
  { &apos;name&apos;: &apos;name.first&apos;},
  &apos;age&apos;,
  &apos;address.planet&apos;
]));
// Will output { name: &apos;Rosario&apos;, age: 3, address: { planet: &apos;earth&apos; } }</code>
</code></pre><h3><code>delete</code></h3><p>Delete a property of an object using a path. If by removing a property of a sub object, the object has no more keys, it also removes it.</p><pre><code class="lang-js"><code class="source-code prettyprint">const target = {
  propOne: {
    propOneSub: &apos;Charito!&apos;,
  },
  propTwo: &apos;!!!&apos;,
};

console.log(ObjectUtils.delete(
  target,
  &apos;propOne.propOneSub&apos;
));
// Will output { propTwo: &apos;!!!&apos; }</code>
</code></pre><h3><code>flat</code></h3><p>Flatterns an object properties into a single level dictionary.</p><pre><code class="lang-js"><code class="source-code prettyprint">const target = {
  propOne: {
    propOneSub: &apos;Charito!&apos;,
  },
  propTwo: &apos;!!!&apos;,
};

console.log(ObjectUtils.flat(target);
// Will output { &apos;propOne.propOneSub&apos;: &apos;Charito!&apos;, propTwo: &apos;!!!&apos; }</code>
</code></pre><h3><code>unflat</code></h3><p>This method does the exact opposite from <code>flat</code>: It takes an already flattern object and restores it structure.</p><pre><code class="lang-js"><code class="source-code prettyprint">const target = {
  &apos;propOne.propOneSub&apos;: &apos;Charito!
  propTwo: &apos;!!!&apos;,
};

console.log(ObjectUtils.unflat(target);
// Will output { propOne: { propOneSub: &apos;Charito!&apos; }, &apos;propTwo&apos;: &apos;!!!&apos; }</code>
</code></pre><h3><code>formatKeys</code></h3><p>Formats all the keys on an object using a way similar to <code>.replace(regexp, ...)</code> but that also works recursively and with <em>&quot;object paths&quot;</em>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const target = {
  prop_one: &apos;Charito!&apos;,
};
console.log(ObjectUtils.formatKeys(
  target,
  // Find all the keys with snake case.
  /([a-z])_([a-z])/g,
  // Using the same .replace style callback, replace it with lower camel case.
  (fullMatch, firstLetter, secondLetter) =&gt; {
    const newSecondLetter = secondLetter.toUpperCase();
    return `${firstLetter}${newSecondLetter}`;
  }
));</code>
</code></pre><p><code>ObjectUtils</code> also provides a few &quot;shorthand implementations&quot; of <code>formatKeys</code>:</p><ul>
<li><code>lowerCamelToSnakeKeys(...)</code></li>
<li><code>lowerCamelToDashKeys(...)</code></li>
<li><code>snakeToLowerCamelKeys(...)</code></li>
<li><code>snakeToDashKeys(...)</code></li>
<li><code>dashToLowerCamelKeys(...)</code></li>
<li><code>dashToSnakeKeys(...)</code></li>
</ul><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/shared/objectUtils.js~ObjectUtils.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/objectUtils.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>SimpleStorage</h1><p>An <strong>abstract</strong> class allows you to build services that relay on browser storage (session/local) and simplifies the way you work it.</p><p>The class doesn&apos;t have any public method, as the idea is for you to define your (let&apos;s call it) <em>&quot;service&quot;</em> and then interact with the storage internally, using the <em>protected</em> methods.</p><h2>Examples</h2><h3>Basic</h3><p>Let&apos;s say you have an app with a form for writing blog posts (or any kind of articles), and it has two fields: title and content.</p><p>The basic functionality is ready, when the user hits the <code>Save</code> button, you send the post to an API in order to publish. We can imagine a service like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Posts {
  save(title, content) {
    return fetch(...);
  }
}</code>
</code></pre><p>But, what if we want to add a feature to save a draft of the post while the user is writing? in case something happens, we can prevent the user from losing what he/she wrote.</p><p>We can use <code>localStorage</code>! we need to write the functions to:</p><ol>
<li>Save the draft, encoded as JSON.</li>
<li>Load the storage, check for the draft, decode it and restore.</li>
</ol><p>And that&apos;s exactly what <code>SimpleStorage</code> can do for you:</p><pre><code class="lang-js"><code class="source-code prettyprint">const SimpleStorage = require(&apos;wootils/browser/simpleStorage&apos;);

class Posts extends SimpleStorage {
  constructor(...) {
    super({
      storage: {
        name: &apos;posts&apos;,
        key: &apos;myApp-posts&apos;,
      },
    });
  }

  saveDraft(title, content) {
    this._setData({ title, content });
  }

  getDraft() {
    const draft = this._getData();
    return draft.title ? draft : null;
  }

  save(title, content) {
    this._delete();
    return fetch(...);
  }
}</code>
</code></pre><p>Let&apos;s go over all the changes:</p><p>We first <code>require</code>/<code>import</code> the class and make <code>Posts</code> extend from it.</p><p>Then we use the constructor options to specify the name and key for the storage. The name is just a reference the class uses and the key is the actual key that will be used on the storage to save the data.</p><blockquote>
<p>Since we wanted <code>localStorage</code>, we don&apos;t need to touch any other default option, but if you are interested on the default options, take a look at the technical documentation for the class.</p>
</blockquote><p>We add <code>saveDraft</code> and <code>getDraft</code>: As you can imagine, <code>saveDraft</code> just tells the class to save an object, and based on the storage options, the class already knows that the object should be encoded as a JSON before saving it, no need to worry about that.</p><p><code>getDraft</code> will just try to obtain the data and make sure there&apos;s a draft there; the whole process where the class checks the storage and loads its contents has been already taken care of.</p><p>The reason we check for <code>.title</code> is because the class will check if there&apos;s something on the storage using the key from the options, and if there&apos;s nothing, it will add an empty object in order to work with future data.</p><p>And the last modification is the call to <code>_delete</code> on the <code>save</code> method: We are going to finally save the post, so it&apos;s ok to delete the draft from the storage: this is basically a <em>&quot;clean up&quot;</em>.</p><p>Now... there&apos;s a problem with this implementation: we are using <code>localStorage</code>, so if the user is writing different posts on different browser tabs, they&apos;ll overwrite each other (yeah, that seems like an odd scenario, but it may happen).</p><p>We should switch to <code>sessionStorage</code> and keep the draft limited to each tab. Doing that with <code>SimpleStorage</code> is quite easy:</p><pre><code class="lang-js"><code class="source-code prettyprint">const SimpleStorage = require(&apos;wootils/browser/simpleStorage&apos;);

class Posts extends SimpleStorage {
  constructor(...) {
    super({
      storage: {
        name: &apos;posts&apos;,
        key: &apos;myApp-posts&apos;,
        typePriority: [&apos;session&apos;, &apos;local&apos;],
      },
    });
  }
...</code>
</code></pre><p>By adding the <code>storage.typePriority</code> option, we tell the class to use <code>sessionStorage</code> if available and switch to <code>localStorage</code> as a fallback.</p><h3>Working with entries</h3><p>On the example above we saw how to save, read and delete a simple object from the storage, but <code>SimpleStorage</code> allows you to also work with different objects: Entries.</p><p>When working with entries, instead of just sending an object to the storage, you can have like a <em>&quot;storage inside the storage&quot;</em>, where you can assign different keys for different objects... and even and expiration time for them.</p><p>Let&apos;s illustrate this with an example: You have an app that, when a user navigates to <em>&quot;its profile page&quot;</em>, it makes some requests to load some &quot;settings&quot;, like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Users {
  ...
  getUserProfileSettings(userId) {
    const result = {};
    this.getUserProfile(userId)
    .then((userProfile) =&gt; {
      result.userProfile = userProfile;
      return this.getUserAppSettings(userId);
    })
    .then((appSettings) =&gt; {
      result.appSettings = appSettings;
      return this.getUserUISettings(userId);
    })
    .then((uiSettings) =&gt; {
      result.uiSettings = uiSettings;
      return result;
    })
    .catch(...)
    .then(() =&gt; {
      this._turnOffThatCrazyAjaxLoadIndicator(): // :P
    });
  }

  getUserProfile(userId) {
    return fetch(`/user-profile/${userId}`)
    .then((resp) =&gt; resp.json());
  }

  getUserAppSettings(userId) {
    return fetch(`/user-app-settings/${userId}`)
    .then((resp) =&gt; resp.json());
  }

  getUserUISettings(userId) {
    return fetch(`/user-ui-settings/${userId}`)
    .then((resp) =&gt; resp.json());
  }
}</code>
</code></pre><blockquote>
<p>Yes, you could also use <code>async</code>/<code>await</code> or <code>Promise.all</code>, but this is just a simple example.</p>
</blockquote><p>But what if we know that it&apos;s hardly possible that those setting would change in the near future and that the app may need to do those requests for more than just the <em>&quot;profile page&quot;</em>?</p><p>We can do something like on the example above and store everything on the local storage, right? well... manipulating a single object in order to put the responses of all the different request will require some extra coding and it may seem like an overkill, so, that&apos;s why <code>SimpleStorage</code> has entries.</p><p>We can use the entries feature to store each request as a different <em>entry</em>, and even tell the class to just keep them for an 2 hours, after that, make the request again.</p><p>Let&apos;s start by adding <code>SimpleStorage</code> and enabling the feature:</p><pre><code class="lang-js"><code class="source-code prettyprint">const SimpleStorage = require(&apos;wootils/browser/simpleStorage&apos;);

class Users extends SimpleStorage {
  constructor(...) {
    super({
      storage: {
        name: &apos;user-requests&apos;,
        key: &apos;myApp-user-requests&apos;,
      },
      entries: {
        enabled: true,
        expiration: 7200,
      }
    });
  }
...</code>
</code></pre><p>We first <code>require</code>/<code>import</code> the class and make <code>Users</code> extend from it.</p><p>Then we use the constructor options to:</p><ol>
<li>Specify the name and key for the storage. The name is just a reference the class uses and the key is the actual key that will be used on the storage to save the data.</li>
<li>Enable the feature <code>entries.enabled</code> and set the expiration time of each entry (2 hours, in seconds).</li>
</ol><p>Now we need to add a method to cache the requests as entries:</p><pre><code class="lang-js"><code class="source-code prettyprint">cacheRequest(url) {
  const entry = this._getEntry(url);
  return entry ?
    Promise.resolve(entry.value) :
    this._saveEntry(fetch(url).then((resp) =&gt; resp.json()));
}</code>
</code></pre><p>As you can see, the method first uses <code>_getEntry</code>, to locate an entry for the received URL.</p><p>If an entry was found, it uses <code>Promise.resolve</code> to return the value. The reason for returning a <code>Promise</code> is so method will always return a promise even if the request doesn&apos;t fire.</p><p>But if there&apos;s no entry, it calls <code>_saveEntry</code> with the result of the <code>fetch</code> request.</p><blockquote>
<p>You can send an object or a promise to <code>_saveEntry</code> and <code>_sendData</code>, the class will wait for it to be resolved and <em>then</em> use the received value.</p>
</blockquote><p>That&apos;s all for the method; like on the other example, <code>SimpleStorage</code> will take care of writing and reading the entries and their values for the storage.</p><p>Time to refactor! We need to change the <em>&quot;get methods&quot;</em> and make them use the new <code>cacheRequest</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">...
getUserProfile(userId) {
  return this.cacheRequest(`/user-profile/${userId}`);
}

getUserAppSettings(userId) {
  return this.cacheRequest(`/user-app-settings/${userId}`);
}

getUserUISettings(userId) {
  return this.cacheRequest(`/user-ui-settings/${userId}`);
}
...</code>
</code></pre><p>Done! Now the request will only trigger if there&apos;s nothing on the storage (this includes entries that were deleted because they expired.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/browser/simpleStorage.js~SimpleStorage.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/simpleStorage.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
