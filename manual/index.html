<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | wootils</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A set of Javascript utilities for building Node and browser apps."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="wootils"><meta property="twitter:description" content="A set of Javascript utilities for building Node and browser apps."></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/wootils"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html" data-ice="link">AppConfiguration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#loading-configurations-dynamically" data-ice="link">Loading configurations dynamically</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#using-it-without-environment-variables-" data-ice="link">Using it without environment variables.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#extending-configurations" data-ice="link">Extending configurations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#get-and-set" data-ice="link">Get and Set</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#reading" data-ice="link">Reading</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#writing" data-ice="link">Writing</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#switching-configurations-while-the-app-is-running" data-ice="link">Switching configurations while the app is running</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/appConfiguration.html"><a href="manual/appConfiguration.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html" data-ice="link">EnvironmentUtils</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#reading-variables" data-ice="link">Reading variables</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#checking-the-environment" data-ice="link">Checking the environment</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/environmentUtils.html"><a href="manual/environmentUtils.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html" data-ice="link">ErrorHandler</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/errorHandler.html"><a href="manual/errorHandler.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/logger.html"><a href="manual/logger.html" data-ice="link">Logger</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/logger.html"><a href="manual/logger.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/logger.html"><a href="manual/logger.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#colored-messages" data-ice="link">Colored messages</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#multiple-messages-at-once" data-ice="link">Multiple messages at once</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#prefix" data-ice="link">Prefix</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#date-and-time" data-ice="link">Date and Time</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/logger.html"><a href="manual/logger.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/logger.html"><a href="manual/logger.html#applogger" data-ice="link">appLogger</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/logger.html"><a href="manual/logger.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html" data-ice="link">packageInfo</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/packageInfo.html"><a href="manual/packageInfo.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html" data-ice="link">PathUtils</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#build-paths-relative-to-the-project-root-directory" data-ice="link">Build paths relative to the project root directory</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#multiple-locations" data-ice="link">Multiple locations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/pathUtils.html"><a href="manual/pathUtils.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html" data-ice="link">rootRequire</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#without-jimple" data-ice="link">Without Jimple</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#with-jimple" data-ice="link">With Jimple</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/rootRequire.html"><a href="manual/rootRequire.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/APIClient.html"><a href="manual/APIClient.html" data-ice="link">APIClient</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/APIClient.html"><a href="manual/APIClient.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/APIClient.html"><a href="manual/APIClient.html#features" data-ice="link">Features</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/APIClient.html"><a href="manual/APIClient.html#configurable-endpoints" data-ice="link">Configurable endpoints</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#endpoint-objects" data-ice="link">Endpoint objects</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#sub-collections-of-endpoints" data-ice="link">Sub collections of endpoints</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#built-in-request-methods" data-ice="link">Built-in request methods</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#default-headers" data-ice="link">Default headers</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/APIClient.html"><a href="manual/APIClient.html#authorization-token" data-ice="link">Authorization token</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/APIClient.html"><a href="manual/APIClient.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/deferred.html"><a href="manual/deferred.html" data-ice="link">deferred</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/deferred.html"><a href="manual/deferred.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/deferred.html"><a href="manual/deferred.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html" data-ice="link">EventsHub</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#examples" data-ice="link">Examples</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#listen-and-emit" data-ice="link">Listen and emit</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#reduce-a-variable" data-ice="link">Reduce a variable</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eventsHub.html"><a href="manual/eventsHub.html#technical-documentation" data-ice="link">Technical documentation</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>AppConfiguration</h1><p>This is a service to manage applications configurations. It takes care of loading, activating, switching and merging configuration files.</p><p>Managing configurations is always a pain on any kind of app, so the idea of this service is to just give it the minimal required information and it will take care of the rest.</p><h2>Example</h2><p>Let&apos;s say your app tree looks like this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>And you execute your app with something like</p><pre><code class="lang-bash"><code class="source-code prettyprint">node app</code>
</code></pre><p>If you don&apos;t have anything managing the configurations, you would probably have something like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">const config = process.NODE_ENV === &apos;production&apos; ?
  require(&apos;../config/production&apos;) :
  require(&apos;../config/development&apos;);</code>
</code></pre><p>Maybe is different, but the point is that you may be checking the <code>NODE_ENV</code> to decide what to <code>require</code>.</p><p>Let&apos;s implement the same scenario with <code>AppConfiguration</code>:</p><blockquote>
<p>The service depends on <code>EnvironmentUtils</code> and <code>RootRequire</code> (which requires <code>PathUtils</code>) so you need to register them first.</p>
</blockquote><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Since Jimple solves the construction of the dependencies, this will be more of a <em>manual process</em>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  AppConfiguration,
  EnvironmentUtils,
  PathUtils,
  rootRequire,
} = require(&apos;wootils/node&apos;);

// Let&apos;s start with `EnvironmentUtils`, which is used to read the env variables.
const environmentUtils = new EnvironmentUtils();
// Now `PathUtils`, to build paths relative to the project root directory.
const pathUtils = new PathUtils();
// `rootRequire` for making `require`s relatives to the root directory.
const rootReq = rootRequire(pathUtils);</code>
</code></pre><p>With all the needed services ready, let&apos;s construct the <code>AppConfiguration</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const appConfiguration = new AppConfiguration(
  environmentUtils,
  rootReq,
  &apos;myApp&apos;,
  {},
  {
    environmentVariable: &apos;CONFIG&apos;,
    path: &apos;./config/&apos;,
    filenameFormat: &apos;[name].js&apos;,
  },
);</code>
</code></pre><p>Done, we first sent the required services and then set the custom options we needed:</p><ol>
<li><code>myApp</code> is the name of the app, the service uses it on the default <code>path</code> and <code>filenameFormat</code> options, but in this case, we don&apos;t really need it for this scenario.</li>
<li><code>{}</code> That&apos;s the default configuration all the others will <em>&apos;extend&apos;</em>, in this case is not needed.</li>
<li>The options:<ul>
<li><code>environmentVariable</code>: The name of the variable the service will check to determine which configuration to use.</li>
<li><code>path</code>: The location of your configuration files.</li>
<li><code>filenameFormat</code>: The name format your files use. <code>[name]</code> will be replaced with the name of the configuration you want to use.</li>
</ul>
</li>
</ol><p>Now, there&apos;s only one thing to do:</p><pre><code class="lang-js"><code class="source-code prettyprint">appConfiguration.loadFromEnvironment();</code>
</code></pre><p>With that, <code>AppConfiguration</code> will check the environment variable and load the configuration you require.</p><pre><code class="lang-bash"><code class="source-code prettyprint"># Load the development configuration
CONFIG=development node app

# Load the production configuration
CONFIG=production node app</code>
</code></pre><h3>With Jimple</h3><p>Let&apos;s create a dummy app and register the dependencies:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const {
  environmentUtils,
  rootRequire,
  pathUtils,
  appConfiguration,
} = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the necessary services
app.register(environmentUtils);
app.register(rootRequire);
app.register(pathUtils);</code>
</code></pre><p>Now, to generate the <code>appConfiguration</code> service with the required settings to work with the scenario described above:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myConfiguration = appConfiguration(
  &apos;myApp&apos;,
  {},
  {
    environmentVariable: &apos;CONFIG&apos;,
    path: &apos;./config/&apos;,
    filenameFormat: &apos;[name].js&apos;,
  },
);
app.register(myConfiguration);</code>
</code></pre><p>Done, the service is registered in the container. Let&apos;s explain a little bit why <em>&apos;those&apos;</em> parameters:</p><ol>
<li><code>myApp</code> is the name of the app, the service uses it on the default <code>path</code> and <code>filenameFormat</code> options, but in this case, we don&apos;t really need it for this scenario.</li>
<li><code>{}</code> That&apos;s the default configuration all the others will <em>&apos;extend&apos;</em>, in this case is not needed.</li>
<li>The options:<ul>
<li><code>environmentVariable</code>: The name of the variable the service will check to determine which configuration to use.</li>
<li><code>path</code>: The location of your configuration files.</li>
<li><code>filenameFormat</code>: The name format your files use. <code>[name]</code> will be replaced with the name of the configuration you want to use.</li>
</ul>
</li>
</ol><p>Now, there&apos;s only one thing to do:</p><pre><code class="lang-js"><code class="source-code prettyprint">app.get(&apos;appConfiguration&apos;).loadFromEnvironment();</code>
</code></pre><p>With that, <code>AppConfiguration</code> will check the environment variable and load the configuration you require.</p><pre><code class="lang-bash"><code class="source-code prettyprint"># Load the development configuration
CONFIG=development node app

# Load the production configuration
CONFIG=production node app</code>
</code></pre><h2>Features</h2><h3>Loading configurations dynamically</h3><p>This was demonstrated on the example above. Instead of you having to manually check and indicate which file to <code>require</code>, <code>AppConfiguration</code> will handle the environment variable and the <code>require</code>, so once you do <code>loadFromEnvironment()</code> you get the configuration you need.</p><h3>Using it without environment variables.</h3><p>This is not the most common case of use, but <code>AppConfiguration</code> allows you to manually load new configurations from an object or from a file:</p><pre><code class="lang-js"><code class="source-code prettyprint">...
appConfiguration.load(&apos;my-new-config&apos;, { valueOne: &apos;one&apos; });</code>
</code></pre><p>or</p><pre><code class="lang-js"><code class="source-code prettyprint">appConfiguration.loadFromFile(&apos;my-new-config&apos;);
// And if you used the options from the example, it will load `/config/my-new-config.js`,
// or at least try :P.</code>
</code></pre><p>The idea of these methods is that if you don&apos;t want to relay on environment variables, you can build your own logic for loading and activating configurations.</p><h3>Extending configurations</h3><p>By default, all the configurations extend from the default one you sent on the constructor, but you can set an <code>extend</code> key on your configurations with the name of the one you want to extend and the service will take care of looking for that configuration and making the new one extend from there.</p><p>If you are using <code>loadFromEnvironment()</code> or <code>loadFromFile()</code> and the configuration to extend is not registered in the service, it will try to load the file; but if you are using <code>load()</code>, the configuration needs to be registered or it will throw an error. It doesn&apos;t sound nice, but the point is to make clear that you are either working with files or with manual configurations.</p><h3>Get and Set</h3><p>Your configuration is not longer a literal object and the service provides a couple of methods to make your life easy when reading or writing settings:</p><h4>Reading</h4><pre><code class="lang-js"><code class="source-code prettyprint">// Read a single setting
const value = appConfiguration.get(&apos;something&apos;);
// Reading multiple settings
const { valueOne, valueTwo } = appConfiguration.get([&apos;valueOne&apos;, &apos;valueTwo&apos;]);</code>
</code></pre><h4>Writing</h4><blockquote>
<p>The changes won&apos;t affect a configuration file, they&apos;ll only affect the configuration loaded on the service.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">// Writing a single setting
appConfiguration.set(&apos;something&apos;, &apos;value&apos;);
// Write multiple settings
appConfiguration.write({
  valueOne: &apos;one&apos;,
  valueTwo: &apos;two&apos;,
});</code>
</code></pre><p>Another cool thing it does is when it writes a setting, if both the current and the new values are both Objects, it will merge them:</p><pre><code class="lang-js"><code class="source-code prettyprint">appConfiguration.set(&apos;person&apos;, {
  name: &apos;Rosario&apos;,
  birthday: &apos;&apos;,
});
appConfiguration.set(&apos;person&apos;, {
  birthday: &apos;25-09-2015&apos;,
});
console.log(appConfiguration.get(&apos;person&apos;));
/**
 * Will output:
 * {
 *   name: &apos;Rosario&apos;,
 *   birthday: &apos;25-09-2015&apos;,
 * }
 */</code>
</code></pre><h3>Switching configurations while the app is running</h3><p>There&apos;s a special rule behind this feature: The default configuration and/or the first configuration loaded needs to have a key name <code>allowConfigurationSwitch</code> set to <code>true</code> in order switch configurations. The reason of this rule is <strong>security</strong>: If you deployed to production and the you didn&apos;t turn off whatever you have that makes the service switch configurations, other people can use it. This way, you can have this enabled only on specifics configuration and disabled on others.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/appConfiguration.js~AppConfiguration.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/appConfiguration.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>EnvironmentUtils</h1><p>A really small service to centralize the place where you read environment variables and check if you are running on development or production.</p><p>Is not uncommon nowadays for Node apps to be checking <code>NODE_ENV</code> and other environment variables in order to do or not to do some stuff, and having multiple calls to <code>process.env</code> on different places of your app may not be a good idea: It&apos;s hard to track and maintain.</p><h2>Example</h2><p>Let&apos;s say your code looks something like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">if (process.env.NODE_ENV !== &apos;production&apos;) {
  addSomeStuffForDevelopment();
}

console.log(`Hello ${process.env.NAME}`);</code>
</code></pre><p>Let&apos;s implement the same but with <code>EnvironmentUtils</code>:</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { EnvironmentUtils } = require(&apos;wootils/node&apos;);
// Construct an instance.
const environmentUtils = new EnvironmentUtils();</code>
</code></pre><p>Now, to update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">if (environmentUtils.development()) {
  addSomeStuffForDevelopment();
}
// The service allows you to set a default in case the variable is not defined.
const name = environmentUtils.get(&apos;NAME&apos;, &apos;Rosario&apos;);
console.log(`Hello ${name}`);</code>
</code></pre><p>Done! Now you are not manually checking for <code>NODE_ENV</code> and all your variables are being read on a single place.</p><h3>With Jimple</h3><p>Let&apos;s setup a dummy app and register the service:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { environmentUtils } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();

app.register(environmentUtils);</code>
</code></pre><p>Now, to update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">// The imported provider has the same name, that&apos;s why I called it `envUtils`.
const envUtils = app.get(&apos;environmentUtils&apos;);
if (envUtils.development()) {
  addSomeStuffForDevelopment();
}
// The service allows you to set a default in case the variable is not defined.
const name = envUtils.get(&apos;NAME&apos;, &apos;Rosario&apos;);
console.log(`Hello ${name}`);</code>
</code></pre><p>Done! Now you are not manually checking for <code>NODE_ENV</code> and all your variables are being read on a single place.</p><h2>Features</h2><h3>Reading variables</h3><p>This was demonstrated on the example above. You just need to <code>.get()</code> with the name of the variable you want to read.</p><h3>Checking the environment</h3><p>No more <code>if (process.env.NODE_ENV ...</code>, <code>EnvironmentUtils</code> does it once when you instantiate it and then gives you <code>production()</code> and <code>development()</code> for you to use.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/environmentUtils.js~EnvironmentUtils.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/environmentUtils.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>ErrorHandler</h1><p>Listens for uncaught exceptions and unhandled promises rejections, and logs them out with full detail.</p><p>By default, if an error is thrown, node will just output the error, but if a <code>Promise</code> is rejected and there&apos;s no <code>catch</code> to capture the exception, it will log <code>...</code>, which doesn&apos;t provide a lot of information, right?</p><p>Well, <code>ErrorHandler</code> listens for these kind of exceptions, unhandled errors and rejected promises, and logs them with their stack trace information using the <code>Logger</code> utility.</p><h2>Example</h2><p>Let&apos;s say your code looks something like this:</p><pre><code class="lang-js"><code class="source-code prettyprint">makeAnAPICall()
.then((response) =&gt; console.log(response));</code>
</code></pre><p>If the request returned a <code>401</code>, Node would output something like this:</p><pre><code class="lang-bash"><code class="source-code prettyprint">(node:34097) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): 401</code>
</code></pre><p>Now, let&apos;s see how to get more information with <code>ErrorHandler</code>:</p><blockquote>
<p>The service depends on a <code>Logger</code> service instance, so you need to register it first.</p>
</blockquote><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><blockquote>
<p>All of this code should be added on top of the already existing code showed above.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger, ErrorHandler } = require(&apos;wootils/node&apos;);
// Create an instance of the logger service
const logger = new Logger();
// Create an instance of the handler
const errorHandler = new ErrorHandler(logger);</code>
</code></pre><p>Now, once you have the instance, you have to tell it to start listening for unhandled errors:</p><pre><code class="lang-js"><code class="source-code prettyprint">errorHandler.listen();</code>
</code></pre><p>Done! If you run the same code now, this is the kind of logged information you&apos;ll get:</p><pre><code class="lang-bash"><code class="source-code prettyprint">[2018-01-22 04:19:12] 401
at makeAPICall (/path-to-your-app/index.js:9:42)
at Object.&lt;anonymous&gt; (/path-to-your-app/index.js:11:1)
at Module._compile (module.js:570:32)
at Object.Module._extensions..js (module.js:579:10)
at Module.load (module.js:487:32)
at tryModuleLoad (module.js:446:12)
at Function.Module._load (module.js:438:3)
at Module.runMain (module.js:604:10)
at run (bootstrap_node.js:383:7)
at startup (bootstrap_node.js:149:9)</code>
</code></pre><p>You get the date and time when it happened and the full stack trace of the error.</p><h3>With Jimple</h3><p>When used with Jimple, instead of using the <code>logger</code> service, it uses the <code>logger</code> service:</p><blockquote>
<p>It uses <code>logger</code> by default, but if the service is not available, it will try to fallback to <code>appLogger</code>, the alternative version of <code>logger</code> that prefixes all the messages with the project name.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const {
  logger,
  errorHandler,
} = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(logger);
// Register the ErrorHandler
app.register(errorHandler);</code>
</code></pre><p>Now, we should tell the service to start listening for errors:</p><pre><code class="lang-js"><code class="source-code prettyprint">app.get(&apos;errorHandler&apos;).listen();</code>
</code></pre><p>Done! If you run the same code now, this is the kind of logged information you&apos;ll get:</p><pre><code class="lang-bash"><code class="source-code prettyprint">[my-app] [2018-01-22 04:29:40] 401
[my-app] at makeAPICall (/path-to-your-app/index.js:9:42)
[my-app] at Object.&lt;anonymous&gt; (/path-to-your-app/index.js:11:1)
[my-app] at Module._compile (module.js:570:32)
[my-app] at Object.Module._extensions..js (module.js:579:10)
[my-app] at Module.load (module.js:487:32)
[my-app] at tryModuleLoad (module.js:446:12)
[my-app] at Function.Module._load (module.js:438:3)
[my-app] at Module.runMain (module.js:604:10)
[my-app] at run (bootstrap_node.js:383:7)
[my-app] at startup (bootstrap_node.js:149:9)</code>
</code></pre><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/errorHandler.js~ErrorHandler.html">online</a> and generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/errorHandler.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Logger</h1><p>The name leaves nothing to the imagination. As you may have guessed, this is service for logging messages into the console.</p><p>It&apos;s not uncommon for Node apps to be logging information into the console all the time: success messages, warnings and even errors; and if you don&apos;t have an already implemented solution for logging, you are probably calling <code>console.[log|info|error]</code> on a bunch of places, which is probably not a great thing to do.</p><p><code>Logger</code> is not a super complete logging system with multiple logging levels and stuff like that, it&apos;s just a simple tool for logging colored messages on the console. </p><h2>Example</h2><p>Let&apos;s say you scenarios like these:</p><pre><code class="lang-js"><code class="source-code prettyprint">console.log(&apos;Starting the app&apos;);

if (usingExperimentalFeature()) {
  console.log(&apos;WARNING: This feature is experimental&apos;);
}

if (onDevelopment()) {
  console.log(&apos;Running on a development environment&apos;);
}

if (loadConfiguration()) {
  console.log(&apos;The configuration was successfully loaded&apos;);
}

try {
  methodThatMayThrowAnError();
} catch (error) {
  console.log(&apos;Damn it!&apos;, error);
}</code>
</code></pre><p>Now, let&apos;s see how to implement the same messages with <code>Logger</code>:</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><blockquote>
<p>All of this code should be added on top of the already existing code showed above.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger } = require(&apos;wootils/node&apos;);
// Create an instance
const logger = new Logger();</code>
</code></pre><p>Now let&apos;s update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">logger.log(&apos;Starting the app&apos;);
// Will log the message the same way `console.log` would.

if (usingExperimentalFeature()) {
  logger.warning(&apos;WARNING: This feature is experimental&apos;);
  // Will log a yellow message.
}

if (onDevelopment()) {
  logger.info(&apos;Running on a development environment&apos;);
  // Will log a gray message.
}

if (loadConfiguration()) {
  logger.success(&apos;The configuration was successfully loaded&apos;);
  // Will log a green message
}

try {
  methodThatMayThrowAnError();
} catch (error) {
  logger.error(&apos;Damn it!&apos;, error);
  // Will log `Damn it!` on read and the `error` stack trace information on `gray`.
}</code>
</code></pre><p>Done, with that your app is now logging the messages with a color referencing the type of message.</p><h3>With Jimple</h3><p>Let&apos;s setup a dummy app and register the service:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { logger } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(logger);</code>
</code></pre><p>Now let&apos;s update the code:</p><pre><code class="lang-js"><code class="source-code prettyprint">// The imported provider is called `logger`, that&apos;s why I named the variable `log`.
const log = app.get(&apos;logger&apos;);

log.log(&apos;Starting the app&apos;);
// Will log the message the same way `console.log` would.

if (usingExperimentalFeature()) {
  log.warning(&apos;WARNING: This feature is experimental&apos;);
  // Will log a yellow message.
}

if (onDevelopment()) {
  log.info(&apos;Running on a development environment&apos;);
  // Will log a gray message.
}

if (loadConfiguration()) {
  log.success(&apos;The configuration was successfully loaded&apos;);
  // Will log a green message
}

try {
  methodThatMayThrowAnError();
} catch (error) {
  logger.error(&apos;Damn it!&apos;, error);
  // Will log `Damn it!` on read and the `error` stack trace information on `gray`.
}</code>
</code></pre><p>Done, with that your app is now logging the messages with a color referencing the type of message.</p><h2>Features</h2><h3>Colored messages</h3><p>This was demonstrated on the example above:</p><ol>
<li><code>success(message)</code> will log a green message.</li>
<li><code>warning(message)</code> will log a yellow message.</li>
<li><code>error(message)</code> will log a red message.</li>
<li><code>info(message)</code> will log a gray message.</li>
</ol><p>But they all depend on this method:</p><p><code>log(message, color)</code> allows you to specify one of the colors available on the <a href="https://yarnpkg.com/en/package/colors"><code>colors</code></a> package. By default, it uses the console default text color.</p><h3>Multiple messages at once</h3><p>All the methods support both a single message or an <code>Array</code> of them:</p><pre><code class="lang-js"><code class="source-code prettyprint">logger.info([&apos;App running&apos;, &apos;connection detected&apos;, &apos;starting Skynet...&apos;]);
// This will log three gray messages.</code>
</code></pre><p>You can even specify a color for each message:</p><pre><code class="lang-js"><code class="source-code prettyprint">logger.success([
  &apos;It works!&apos;,
  [&apos;wait, something is happening&apos;, &apos;gray&apos;],
  &apos;Nevermind, Skynet is up and running!&apos;,
]);
// This will log the first and third message on green and the second one on gray.</code>
</code></pre><h3>Prefix</h3><p>When constructing the service or when generating the provider, you can specify a <code>prefix</code> that will be added to every message:</p><h4>Without Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger } = require(&apos;wootils/node&apos;);
// Create an instance
const logger = new Logger(&apos;my-app&apos;);

logger.success(&apos;The instance was created!&apos;);
// This will log `[my-app] The instance was created!` on green.</code>
</code></pre><h4>With Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { loggerWithOptions } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(loggerWithOptions(&apos;my-app&apos;));

app.get(&apos;logger&apos;).success(&apos;The instance was created!&apos;);
// This will log `[my-app] The instance was created!` on green.</code>
</code></pre><h3>Date and Time</h3><p>When constructing the service or when generating the provider, you can specify whether or not you would like to show the date and time on every message. By default, it only does it for errors:</p><h4>Without Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">const { Logger } = require(&apos;wootils/node&apos;);
// Create an instance
const logger = new Logger(&apos;my-app&apos;, true);

logger.success(&apos;The instance was created!&apos;);
// This will log `[my-app][YYYY-MM-DD HH:MM:SS] The instance was created!` on green.</code>
</code></pre><h4>With Jimple</h4><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { loggerWithOptions } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(loggerWithOptions(&apos;my-app&apos;, true));

app.get(&apos;logger&apos;).success(&apos;The instance was created!&apos;);
// This will log `[my-app][YYYY-MM-DD HH:MM:SS] The instance was created!` on green.</code>
</code></pre><h3>appLogger</h3><p>This is only for Jimple implementations. <code>appLogger</code> is a service provider that uses the service <code>packageInfo</code> to obtain the app name from the <code>package.json</code> and automatically use it as the <code>prefix</code> for every message.</p><p>Let&apos;s say the <code>name</code> of your app on your <code>package.json</code> is <code>skynet</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { appLogger } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the logger
app.register(appLogger);

app.get(&apos;appLogger&apos;).success(&apos;The instance was created!&apos;);
// This will log `[skynet] The instance was created!` on green.</code>
</code></pre><p>There&apos;s also <code>appLoggerWithOptions</code> that allows you to enable or disabled the date and time for the messages.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/logger.js~Logger.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/logger.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>packageInfo</h1><p>A tiny function that reads the contents of the app <code>package.json</code>. This is really useful on an Jimple application where you can register it, because the returned value gets cached and it&apos;s available as a service.</p><h2>Example</h2><p>Even if the function is really small (one line to be exact), it has a dependency: <code>PathUtils</code>. It uses it to build the path to the <code>package.json</code> relative to the project root directory.</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { PathUtils, packageInfo } = require(&apos;wootils/node&apos;);
// Create an instance of the dependency.
const pathUtils = new PathUtils();

// Now, let&apos;s use the function
const packageJson = packageInfo(pathUtils);</code>
</code></pre><p>Done, <code>packageJson</code> now has all the contents of your <code>package.json</code>, as an Object.</p><h3>With Jimple</h3><p>First, let&apos;s setup a dummy app and register the dependency and the service itself:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { pathUtils, packageInfo } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the dependency
app.register(pathUtils);
// Register the service
app.register(packageInfo);</code>
</code></pre><p>Now, to use it:</p><pre><code class="lang-js"><code class="source-code prettyprint">const packageJson = app.get(&apos;packageInfo&apos;);</code>
</code></pre><p>Done, <code>packageJson</code> now has all the contents of your <code>package.json</code>, as an Object; and the file won&apos;t be read more than once.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/function/index.html#static-function-packageInfo">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/packageInfo.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>PathUtils</h1><p>An easy way to manage locations and build paths relative to those locations on a Node app.</p><p>When writing static <code>require</code> statements is easy: The file you are requiring is relative to the one where you are writing the <code>require</code>. But when you are reading files or doing <code>require</code> with dynamic paths, it can get messy pretty fast, and that&apos;s where this utility shines.</p><h2>Example</h2><p>Let&apos;s say your app tree looks like this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>And you want to access <code>config/development.js</code>, but when you build your app, or prepare it to deployment, it becomes this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; dist/
&#x2502;   &#x2514;&#x2500;&#x2500; app/
&#x2502;       &#x2514;&#x2500;&#x2500; index.min.js
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>There&apos;s a lot of ways to check whether you need to call <code>../config</code> or <code>../../config</code>: <code>TryCatch</code>, check some environment variable, check if <code>../config</code> exists, etc. Well, with <code>PathUtils</code>, you don&apos;t need to do that, because the service knowns that if you ask for <code>config/development.js</code>, it&apos;s relative to your project root directory.</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">// Require the class.
const { PathUtils } = require(&apos;wootils/node&apos;);
// Instantiate it.
const pathUtils = new PathUtils();</code>
</code></pre><p>Now that you have the service instance, getting the path is easy as:</p><pre><code class="lang-js"><code class="source-code prettyprint">const devConfigPath = pathUtils.join(&apos;config/development&apos;);</code>
</code></pre><p>Done, now you can use either <code>require</code> or <code>fs</code> to get the contents of the file.</p><h3>With Jimple</h3><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { pathUtils } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the service
app.register(pathUtils);</code>
</code></pre><p>Now that you have the service instance, getting the path is easy as:</p><pre><code class="lang-js"><code class="source-code prettyprint">const devConfigPath = app.get(&apos;pathUtils&apos;).join(&apos;config/development&apos;);</code>
</code></pre><p>Done, now you can use either <code>require</code> or <code>fs</code> to get the contents of the file.</p><h2>Features</h2><h3>Build paths relative to the project root directory</h3><p>This was demonstrated on the example above. The <code>join</code> method works exactly like <code>path.join</code>, you can send any number of parameters and they will be merged on one single path.</p><pre><code class="lang-js"><code class="source-code prettyprint">pathUtils.join(&apos;config&apos;, &apos;development.js&apos;);
// is the same as
pathUtils.join(&apos;config/development.js&apos;);</code>
</code></pre><h3>Multiple locations</h3><p>By default, <code>PathUtils</code> uses the <code>home</code> location, which is the project root directory, but it also has an <code>app</code> location and the ability to register new locations:</p><p>The <code>app</code> location is the directory where your app executable file is located, for the project tree used on the example above, the <code>app</code> location is <code>/app</code> on development, and <code>/dist/app</code> when builded/deployed.</p><p>To register new locations, you use the <code>addLocation</code> method:</p><pre><code class="lang-js"><code class="source-code prettyprint">pathUtils.addLocation(&apos;my-location&apos;, &apos;some-folder/some-sub-folder&apos;);</code>
</code></pre><p>The new location path <strong>must</strong> be relative to your project root directory.</p><p>And finally, to use those locations, you use <code>joinFrom</code> instead of <code>join</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const pathToFile = pathUtils.joinFrom(&apos;my-location&apos;, &apos;some-file.js&apos;);</code>
</code></pre><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/node/pathUtils.js~PathUtils.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/pathUtils.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>rootRequire</h1><p>Is basically <code>require</code> but the path is relative to the project root directory.</p><p>This is very useful when working with dynamic <code>require</code> statements and project that when bundled or deployed change locations.</p><h2>Example</h2><p>Let&apos;s say your app tree looks like this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>And you want to access <code>config/development.js</code>, but when you build your app, or prepare it to deployment, it becomes this:</p><pre><code><code class="source-code prettyprint">myApp/
&#x251C;&#x2500;&#x2500; dist/
&#x2502;   &#x2514;&#x2500;&#x2500; app/
&#x2502;       &#x2514;&#x2500;&#x2500; index.min.js
&#x251C;&#x2500;&#x2500; config/
&#x2502;   &#x251C;&#x2500;&#x2500; development.js
&#x2502;   &#x2514;&#x2500;&#x2500; production.js
&#x2514;&#x2500;&#x2500; app/
    &#x2514;&#x2500;&#x2500; index.js</code>
</code></pre><p>There&apos;s a lot of ways to check whether you need to call <code>../config</code> or <code>../../config</code>: <code>TryCatch</code>, check some environment variable, check if <code>../config</code> exists, etc.  Well, with <code>rootRequire</code>, you don&apos;t need to do that, because the service knowns that if you ask for <code>config/development.js</code>, it&apos;s relative to your project root directory.</p><p>Now, before taking a look a how we would implement this with root require, the function, even as small as it is, it has a dependency: <code>PathUtils</code>. It uses it to build the paths relative to the project root directory.</p><h3>Without Jimple</h3><blockquote>
<p>If you haven&apos;t tried <a href="https://github.com/fjorgemota/jimple">Jimple</a>, give it a try, it&apos;s excellent for organizing your app dependencies and services.</p>
</blockquote><p>Let&apos;s start with the setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { PathUtils, rootRequire } = require(&apos;wootils/node&apos;);
// Create an instance of the dependency.
const pathUtils = new PathUtils();

// Now, let&apos;s generate the function
const rootReq = rootRequire(pathUtils);
// And finally use it to get the file
const config = rootReq(&apos;config/development&apos;);</code>
</code></pre><p>Done, <code>config</code> now has the contents of <code>config/development</code>, and this will work no matter where the app file is located.</p><h3>With Jimple</h3><p>First, let&apos;s setup a dummy app and register the dependency and the service itself:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Import all the required modules
const Jimple = require(&apos;jimple&apos;);
const { pathUtils, rootRequire } = require(&apos;wootils/node/providers&apos;);
// Create a dummy app
const app = new Jimple();
// Register the dependency
app.register(pathUtils);
// Register the service
app.register(rootRequire);</code>
</code></pre><p>Now, to use it:</p><pre><code class="lang-js"><code class="source-code prettyprint">const config = app.get(&apos;rootRequire&apos;)(&apos;config/development&apos;);</code>
</code></pre><p>Done, <code>config</code> now has the contents of <code>config/development</code>, and this will work no matter where the app file is located.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/function/index.html#static-function-rootRequire">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/rootRequire.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>APIClient</h1><p>A really basic client to work with an API endpoints requests.</p><p>Nowadays there&apos;s almost no app that doesn&apos;t make requests to one or more external APIs, that&apos;s why I built this service.</p><p>Now, the reason this is marked as <em>&apos;shared&apos;</em> it&apos;s because it basically organizes the API configuration and prepares the requests, but you have to give it a <code>fetch</code> client to make the request. It&apos;s <em>&apos;shared&apos;</em> because on a browser you can give it the native <code>fetch</code> function, and on Node, something like <code>node-fetch</code> or <code>axios</code>, but that supports the native <code>fetch</code> signature.</p><h2>Examples</h2><blockquote>
<p>This example will be on Node, so I&apos;ll use <a href="https://yarnpkg.com/en/package/node-fetch"><code>node-fetch</code></a> as fetch client.</p>
</blockquote><p>First, let&apos;s start by creating the configuration:</p><pre><code class="lang-js"><code class="source-code prettyprint">const url = &apos;https://my-api.com&apos;;
const endpoints: {
  login: &apos;auth/login&apos;,
  profile: &apos;users/:userId&apos;,
  users: &apos;users&apos;,
};
const fetchClient = require(&apos;node-fetch&apos;);</code>
</code></pre><p>You need those three things to instantiate the client:</p><ol>
<li>An entry point for your API.</li>
<li>A dictionary of endpoints (Check the <strong>features</strong> section to see all the possible ways to define an endpoint).</li>
<li>A fetch client to make the requests.</li>
</ol><p>Now, to instantiate the client:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { APIClient } = require(&apos;wootils/shared&apos;);

const client = new APIClient(url, endpoints, fetchClient);</code>
</code></pre><p>To make a request, you first need to generate an endpoint and use it to call the method of the type of request you want to make.</p><p>Let&apos;s say you want to authenticate a user, which is a <code>POST</code> request to the <code>login</code> endpoint with a body that includes <code>username</code> and <code>password</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.post(client.endpoint(&apos;login&apos;), {
  username: &apos;Rosario&apos;,
  password: &apos;charito&apos;,
})
.then((response) =&gt; {
  // Do something...
});</code>
</code></pre><p>Ok, that one was easy, no extra options or parameters. Next will request some user information from the <code>profile</code> endpoint, a <code>GET</code> request that requires a <code>userId</code> parameter:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.get(client.endpoint(&apos;profile&apos;, { userId: 2509 }), {
  username: &apos;Rosario&apos;,
  password: &apos;charito&apos;,
})
.then((response) =&gt; {
  // Do something...
});</code>
</code></pre><p>Easy enough, right? Well, for the last example, we&apos;ll make a request to get the users directory to the <code>users</code> endpoint, a <code>GET</code> request and we&apos;ll include a query string parameter to <em>&quot;limit the number of returned users&quot;</em>:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.get(client.endpoint(&apos;users&apos;, { count: 10 }), {
  username: &apos;Rosario&apos;,
  password: &apos;charito&apos;,
})
.then((response) =&gt; {
  // Do something...
});</code>
</code></pre><p>Done! If the parameter doesn&apos;t have a placeholder on the endpoint path, it gets automatically added on the query string.</p><h2>Features</h2><h3>Configurable endpoints</h3><p>On the example above, all the endpoints were strings, but you can define them as objects to include default query string parameters, or even as sub collections of endpoints:</p><h4>Endpoint objects</h4><pre><code class="lang-js"><code class="source-code prettyprint">const endpoints = {
  users: {
    path: &apos;users&apos;,
    query: {
      count: 10,
      offset: null,
    },
  },
};</code>
</code></pre><p>In that case, if <code>count</code> is not specified on <code>endpoint(...)</code>, it will have a default value of <code>10</code>.</p><p>And if <code>offset</code> is not specified, it won&apos;t be sent. The reason the configuration supports <em>&quot;nullable&quot;</em> parameters is so they can be used like some sort of documentation for the endpoint: <em>&quot;It&apos;s not used, but there&apos;s an optional parameter called ...&quot;</em>.</p><h4>Sub collections of endpoints</h4><pre><code class="lang-js"><code class="source-code prettyprint">const endpoints = {
  login: &apos;auth/login&apos;,
  users: {
    profile: &apos;users/:userId&apos;,
    directory: {
      path: &apos;users&apos;,
      query: {
        count: 10,
      },
    },
  },
};</code>
</code></pre><p>As you can see, both users related endpoints are now under <code>users</code>, and <code>login</code> is still on the top level. To access <em>&quot;sub endpoints&quot;</em> you use dot notation:</p><pre><code class="lang-js"><code class="source-code prettyprint">const endpointURL = client.endpoint(&apos;users.profile&apos;, { userId: 2509 });</code>
</code></pre><p>This allows you to organize the scopes of your endpoints and make the configuration easier to read.</p><h4>Built-in request methods</h4><p>On the example above we saw only <code>.get</code> and <code>.post</code>, but the client comes with these already built-in request methods:</p><ul>
<li><code>.get(url, options = {})</code></li>
<li><code>.head(url, options = {})</code></li>
<li><code>.post(url, body, options = {})</code></li>
<li><code>.put(url, body, options = {})</code></li>
<li><code>.patch(url, body, options = {})</code></li>
<li><code>.delete(url, body = {}, options = {})</code></li>
</ul><p>If you are wondering what <code>options</code> are, well, they are extra options for the <code>fetch</code> client call. It can include headers, another method, another body, etc. Everything that could send on the <code>fetch</code> call second parameter.</p><h4>Default headers</h4><p>The client allows you to set a dictionary of default headers you want to include on every request.</p><p>For example, let&apos;s say you are on a development environment and you want all your request to go out with the header <code>x-development</code> set to <code>true</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.setDefaultHeaders({
  &apos;x-development&apos;: true,
});</code>
</code></pre><p>Now, all the outgoing requests will include that header.</p><h4>Authorization token</h4><p>If you are working with an API that requires authorization on every requests, and that provides you with a bearer token when you authenticate, you could set it on the client and it will automatically include the <code>Authorization</code> header on every request and send the token:</p><pre><code class="lang-js"><code class="source-code prettyprint">client.setAuthorizationToken(&apos;some-token&apos;);</code>
</code></pre><p>Done, all the requests will include <code>Authorization: Bearer some-token</code>.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/shared/apiClient.js~APIClient.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/APIClient.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>deferred</h1><p>Create a deferred promise using the native <code>Promise</code> object.</p><h2>Example</h2><p>Using it is really simple, you call the <code>deferred()</code> function and get an object with <code>promise</code>, <code>resolve</code> and <code>reject</code>. You return the <code>promise</code> property and then call <code>resolve</code> or <code>reject</code> to either resolve the promise or reject it.</p><p>Now, a reason to use this is for when you have another service/function/something asking for something that your code hasn&apos;t even started to do:</p><blockquote>
<p>I&apos;m using Node and <a href="https://yarnpkg.com/en/package/fs-extra"><code>fs-extra</code></a> because of the Promise based interface for <code>fs</code>.</p>
</blockquote><pre><code class="lang-js"><code class="source-code prettyprint">const fs = require(&apos;fs-extra&apos;);
const { deferred } = require(&apos;wootils/shared&apos;);

class MyServiceThatLoadsAfile {
  constructor() {
    this._defer = deferred();
    this._fileContents = null;
  }

  getFileContents() {
    return this._fileContents ?
      Promise.resolve(this._fileContents) :
      this._defer.promise;
  }

  loadTheFile() {
    return fs.readFile(&apos;some-path&apos;, &apos;utf-8&apos;)
    .then((contents) =&gt; {
      this._fileContents = contents;
      this.defer.resolve(contents);
    })
    .catch((error) =&gt; {
      this.defer.reject(error);
    });
  }
}

const myService = new MyServiceThatLoadsAfile();
myService.getFileContents()
.then((contents) =&gt; {
  console.log(&apos;GOT IT&apos;, contents);
});

// ...
myService.loadTheFile();</code>
</code></pre><p>Ok, there&apos;s a lot going on this example, let&apos;s break it:</p><ol>
<li><code>MyServiceThatLoadsAFile</code> creates a deferred promise on its constructor.</li>
<li><code>getFileContents</code> should return the file contents, but because the file is not loaded yet (because <code>loadTheFile</code> has not been called), it returns the deferred promise.</li>
<li>Eventually, <code>loadTheFile</code> gets called, it loads the file and either resolves or rejects the deferred promise, so the <code>getFileContents().then(...)</code> gets finally called.</li>
</ol><p>I wanted to keep the example small, but on a real app, <code>getFileContents</code> is probably called by other service that has no idea the instance was just created or that <code>loadTheFile</code> hasn&apos;t been called yet.</p><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/function/index.html#static-function-deferred">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/deferred.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>EventsHub</h1><p>A small implementation of a pubsub service for handling events on an app.</p><p>It doesn&apos;t require any configuration or have customization options: You listen for an event with <code>on</code>, emit an event with <code>emit</code> and reduce a variable through an event with <code>reduce</code>.</p><h2>Examples</h2><p>First, let&apos;s create an instance of the hub:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { EventsHub } = require(&apos;wootils/shared&apos;);
const events = new EventsHub();</code>
</code></pre><h3>Listen and emit</h3><pre><code class="lang-js"><code class="source-code prettyprint">// Add the listener
events.on(&apos;my-event&apos;, () =&gt; {
  console.log(&apos;The event listener was called!&apos;);
});
// Emit the event
events.emit(&apos;my-event&apos;);</code>
</code></pre><p>Quite simple, right? You can also send any number of parameters to the events:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Add the listener
events.on(&apos;user-login&apos;, (username, password) =&gt; {
  someAuthService.login(username, password)
  .then((userInfo) =&gt; {
    events.emit(&apos;user-login-successfull&apos;, userInfo);
  })
  .catch((error) =&gt; {
       events.emit(&apos;user-login-failed&apos;, error);
  });
});

...

events.emit(&apos;user-login&apos;, &apos;rosario&apos;, &apos;p4ssword&apos;);</code>
</code></pre><p>And you can even use the same listener for multiple events:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Add the listener
events.on([&apos;logout-route&apos;, &apos;unauthorized-request&apos;], () =&gt; {
  someAuthService.signout();
});

...

events.emit(&apos;logout-route&apos;);
// or
someRequest()
.then(() =&gt; ... )
.catch((error) =&gt; {
  if (error.code === 401) {
    events.emit(&apos;unauthorized-request&apos;);
  }
})</code>
</code></pre><blockquote>
<p>All methods that support an event name also support an <code>Array</code> with a list of them.</p>
</blockquote><h3>Reduce a variable</h3><p>It&apos;s basically the same as calling <code>emit</code>, but the first parameter may be modified by the listeners and it&apos;s returned after it went through all of them.</p><pre><code class="lang-js"><code class="source-code prettyprint">events.on(&apos;filter-users-list&apos;, (list) =&gt; {
  list.splice(1, 1);
  return list;
});

const usersList = [&apos;charito&apos;, &apos;Rosario&apos;];
const newUsersList = events.reduce(&apos;filter-users-list&apos;, usersList);
console.log(newUsersList);
// Will log [&apos;charito&apos;]</code>
</code></pre><blockquote>
<p><code>reduce</code> also supports sending any number of parameters after the target variable.</p>
</blockquote><h2>Technical documentation</h2><p>The code is fully documented with <a href="https://esdoc.org">ESDoc</a> and you can either read the generated documentation <a href="https://homer0.github.io/wootils/class/wootils/shared/eventsHub.js~EventsHub.html">online</a> or generate it yourself using:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># You can either use npm or yarn, it doesn&apos;t matter
npm run docs
open ./docs/index.html</code>
</code></pre></div>
        <a data-ice="link" href="manual/eventsHub.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
