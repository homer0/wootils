jest.unmock('/node/pathUtils');
jest.mock('jimple', () => ({ provider: jest.fn(() => 'provider') }));

require('jasmine-expect');
const path = require('path');
const {
  PathUtils,
  pathUtils,
  pathUtilsWithHome,
} = require('/node/pathUtils');
const { provider } = require('jimple');

const originalProcesssCwd = process.cwd;

describe('PathUtils', () => {
  beforeEach(() => {
    process.cwd = originalProcesssCwd;
  });

  it('should be instantiated with the current directory (cwd) as home/base', () => {
    // Given
    const home = '/some-folder/';
    process.cwd = jest.fn(() => home);
    let sut = null;
    // When
    sut = new PathUtils();
    // Then
    expect(sut.path).toBe(home);
    expect(process.cwd).toHaveBeenCalledTimes(1);
  });

  it('should have getters for the app and home locations', () => {
    // Given
    const home = '/some-folder/';
    process.cwd = jest.fn(() => home);
    let sut = null;
    let homePath = null;
    let appPath = null;
    // The `substr` is to remove the leading `/`
    const thisfilePath = __dirname.substr(1);
    const expectedAppPath = `${home}${thisfilePath}/`;
    // When
    sut = new PathUtils();
    homePath = sut.home;
    appPath = sut.app;
    // Then
    expect(homePath).toBe(home);
    expect(appPath).toBe(expectedAppPath);
  });

  it('should be able to be instantiated with a custom home/base ', () => {
    // Given
    const customHome = '/custom-folder/';
    const home = '/some-folder/';
    process.cwd = jest.fn(() => home);
    let sut = null;
    // When
    sut = new PathUtils(customHome);
    // Then
    expect(sut.path).toBe(home);
    expect(sut.home).toBe(path.join(home, customHome));
    expect(process.cwd).toHaveBeenCalledTimes(1);
  });

  it('should be able to join multiple paths using the home as origin', () => {
    // Given
    const home = '/some-folder/';
    const testPathOne = '/sub-dir-one/';
    const testPathTwo = '/sub-file.js';
    process.cwd = jest.fn(() => home);
    let sut = null;
    let result = null;
    // When
    sut = new PathUtils();
    result = sut.join(testPathOne, testPathTwo);
    // Then
    expect(result).toBe(path.join(home, testPathOne, testPathTwo));
  });

  it('should be able to add a custom location', () => {
    // Given
    const home = '/some-folder/';
    const locationName = 'customLocation';
    const locationPath = '/custom-location/';
    process.cwd = jest.fn(() => home);
    let sut = null;
    let result = null;
    // When
    sut = new PathUtils();
    sut.addLocation(locationName, locationPath);
    result = sut.getLocation(locationName);
    // Then
    expect(result).toBe(path.join(home, locationPath));
  });

  it('should throw an error if a requested location doesn\'t exist', () => {
    // Given
    let sut = null;
    // When
    sut = new PathUtils();
    // When-Then
    expect(() => sut.getLocation('custom')).toThrow(/there's no location/i);
  });

  it('should have a Jimple provider to register the service', () => {
    // Given
    const container = {
      set: jest.fn(),
    };
    let sut = null;
    let serviceProvider = null;
    let serviceName = null;
    let serviceFn = null;
    // When
    [[serviceProvider]] = provider.mock.calls;
    serviceProvider(container);
    [[serviceName, serviceFn]] = container.set.mock.calls;
    sut = serviceFn();
    // Then
    expect(pathUtils).toBe('provider');
    expect(provider).toHaveBeenCalledTimes(1);
    expect(serviceName).toBe('pathUtils');
    expect(serviceFn).toBeFunction();
    expect(sut).toBeInstanceOf(PathUtils);
  });

  it('should have a customizable Jimple provider to set an specific home/base', () => {
    // Given
    const customHome = '/custom-folder/';
    const home = '/some-folder/';
    process.cwd = jest.fn(() => home);
    const container = {
      set: jest.fn(),
    };
    let sut = null;
    let registerResult = null;
    let serviceProvider = null;
    let serviceName = null;
    let serviceFn = null;
    // When
    registerResult = pathUtilsWithHome(customHome);
    /**
     * The first one is the one for the default provider, the second one is
     * the one generated by this test.
     */
    [, [serviceProvider]] = provider.mock.calls;
    serviceProvider(container);
    [[serviceName, serviceFn]] = container.set.mock.calls;
    sut = serviceFn();
    // Then
    expect(registerResult).toBe('provider');
    expect(serviceName).toBe('pathUtils');
    expect(serviceFn).toBeFunction();
    expect(sut).toBeInstanceOf(PathUtils);
    expect(sut.path).toBe(home);
    expect(sut.home).toBe(path.join(home, customHome));
  });
});
